@page "/projects/edit/{id:int}"

@rendermode InteractiveServer
@attribute [Authorize]

@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.Authorization
@using Microsoft.EntityFrameworkCore
@using StoryDesignSupportWebApp.Data
@using StoryDesignSupportWebApp.Data.EditData
@inject UserManager<ApplicationUser> UserManager
@inject IDbContextFactory<ApplicationDbContext> DbFactory
@inject NavigationManager Nav
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IJSRuntime JSRuntime

<PageTitle>Project Edit</PageTitle>

<style>
    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }

    body {
        overflow: hidden;
    }

    .edit-container {
        display: flex;
        height: calc(100vh - 5.5rem);
        overflow: hidden;
        max-width: 97vw;
    }

    /* サイドバー（PC用） */
    .sidebar {
        width: 300px;
        background-color: #f5f5f5;
        border-right: 1px solid #ddd;
        display: flex;
        flex-direction: column;
        overflow-y: auto;
    }

    .sidebar-header {
        padding: 15px;
        border-bottom: 1px solid #ddd;
        background-color: #fff;
        cursor: pointer;
        color: #0066cc;
    }

        .sidebar-header:hover {
            background-color: #f0f0f0;
        }

    .category-view, .chapter-view {
        flex: 1;
        overflow-y: auto;
    }

    .category-item {
        padding: 15px 20px;
        border-bottom: 1px solid #e0e0e0;
        cursor: pointer;
        transition: background-color 0.2s;
    }

        .category-item:hover {
            background-color: #e8e8e8;
        }

        .category-item.active {
            background-color: #0066cc;
            color: white;
        }

    .chapter-item {
        border-bottom: 1px solid #e0e0e0;
    }

    .chapter-header {
        padding: 12px 20px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: #fff;
    }

        .chapter-header:hover {
            background-color: #f0f0f0;
        }

    .chapter-title {
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .toggle-icon {
        margin-right: 10px;
        font-size: 12px;
    }

    .add-section-btn {
        background: none;
        border: none;
        color: #0066cc;
        cursor: pointer;
        font-size: 18px;
        padding: 0 8px;
    }

        .add-section-btn:hover {
            color: #0052a3;
        }

    .sections-list {
        background-color: #fafafa;
    }

    .section-item {
        padding: 10px 20px 10px 40px;
        cursor: pointer;
        border-bottom: 1px solid #e8e8e8;
        position: relative;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

        .section-item::before {
            content: "・";
            position: absolute;
            left: 16px;
        }

        .section-item:hover {
            background-color: #e8e8e8;
        }

        .section-item.active {
            background-color: #0066cc;
            color: white;
        }

    .add-chapter-btn {
        padding: 15px 20px;
        background-color: #fff;
        border: none;
        border-top: 1px solid #ddd;
        cursor: pointer;
        color: #0066cc;
        text-align: left;
    }

        .add-chapter-btn:hover {
            background-color: #f0f0f0;
        }

    .empty-message {
        padding: 20px;
        text-align: center;
        color: #999;
    }

    /* 編集エリア */
    .editor-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        min-width: 0;
    }

    .editor-header {
        padding: 15px 20px;
        border-bottom: 1px solid #ddd;
        background-color: #fff;
        overflow: hidden;
    }

    .editor-title {
        font-size: 20px;
        font-weight: bold;
        margin-bottom: 10px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        max-width: 100%;
    }

    .section-title-input {
        width: 100%;
        padding: 8px;
        font-size: 16px;
        border: 1px solid #ddd;
        border-radius: 4px;
        box-sizing: border-box;
    }

    .editor-toolbar {
        padding: 10px;
        background-color: #f9f9f9;
        border-bottom: 1px solid #ddd;
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        align-items: center;
    }

    .toolbar-btn {
        padding: 6px 12px;
        background-color: #fff;
        border: 1px solid #ccc;
        border-radius: 3px;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.2s;
    }

        .toolbar-btn:hover {
            background-color: #e8e8e8;
        }

        .toolbar-btn.active {
            background-color: #0066cc;
            color: white;
            border-color: #0066cc;
        }

    .toolbar-separator {
        width: 1px;
        height: 20px;
        background-color: #ccc;
        margin: 0 5px;
    }

    .color-picker-wrapper {
        display: flex;
        align-items: center;
        gap: 5px;
        padding: 4px 8px;
        background-color: #fff;
        border: 1px solid #ccc;
        border-radius: 3px;
    }

    .color-picker {
        width: 30px;
        height: 24px;
        border: none;
        cursor: pointer;
    }

    .editor-content {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
    }

    .content-editable {
        min-height: 400px;
        padding: 15px;
        border: none;
        border-radius: 4px;
        font-size: 16px;
        font-family: inherit;
        line-height: 1.6;
        outline: none;
        background-color: white;
        word-wrap: break-word;
        overflow-wrap: break-word;
    }

        .content-editable:focus {
            border-color: none;
        }

        /* 各要素の行間を明示的に指定 */
        .content-editable p {
            line-height: 1.6;
            margin: 0;
        }

        .content-editable h1 {
            line-height: 1.3;
            margin: 0;
        }

        .content-editable h2 {
            line-height: 1.3;
            margin: 0;
        }

        .content-editable h3 {
            line-height: 1.3;
            margin: 0;
        }

        .content-editable b,
        .content-editable strong,
        .content-editable i,
        .content-editable em,
        .content-editable u {
            line-height: inherit;
        }

        .content-editable ruby {
            line-height: inherit;
            cursor: text;
        }

        .content-editable rt {
            font-size: 0.5em;
        }

    /* モバイルビュー */
    .mobile-view {
        display: none;
        height: calc(100vh - 5.5rem);
        overflow: hidden;
    }

    .mobile-list {
        height: calc(100vh - 5.5rem);
        overflow-y: auto;
        background-color: #f5f5f5;
    }

    .mobile-header {
        padding: 15px;
        background-color: #0066cc;
        color: white;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .mobile-editor {
        height: calc(100vh - 5.5rem);
        display: flex;
        flex-direction: column;
        background-color: #fff;
    }

    .mobile-editor-header {
        padding: 15px;
        background-color: #0066cc;
        color: white;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .back-btn {
        background: none;
        border: none;
        color: white;
        font-size: 18px;
        cursor: pointer;
        padding: 0;
    }

    .mobile-editor-title {
        flex: 1;
        font-size: 18px;
        font-weight: bold;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    /* モーダル */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
    }

    .modal-content {
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        min-width: 300px;
        max-width: 450px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    .modal-header {
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 15px;
    }

    .modal-body {
        margin-bottom: 20px;
    }

    .modal-input {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
    }

    .modal-buttons {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
    }

    .modal-btn {
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }

    .modal-btn-primary {
        background-color: #0066cc;
        color: white;
    }

        .modal-btn-primary:hover {
            background-color: #0052a3;
        }

    .modal-btn-danger {
        background-color: #dc3545;
        color: white;
    }

        .modal-btn-danger:hover {
            background-color: #c82333;
        }

    .modal-btn-secondary {
        background-color: #6c757d;
        color: white;
    }

        .modal-btn-secondary:hover {
            background-color: #5a6268;
        }

    .settings-btn {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 16px;
        padding: 0 8px;
        margin-left: 4px;
        margin-right: -10px;
        color: #666;
    }

        .settings-btn:hover {
            color: #333;
        }

    .delete-section-btn {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 16px;
        padding: 0 8px;
        margin-left: 4px;
        margin-right: -8px;
        color: #ff2222;
        font-weight: bold;
    }

    .delete-section:hover {
        color: #ff1111;
    }

    .modal-section {
        margin-bottom: 15px;
    }

        .modal-section:last-child {
            margin-bottom: 0;
        }

    /* レスポンシブ */
    @@media (max-width: 768px) {
        .desktop-view {
            display: none !important;
        }

        .mobile-view {
            display: block;
            width: 100%;
        }

        .toolbar-btn {
            padding: 8px 10px;
            font-size: 12px;
        }

        .editor-toolbar {
            padding: 8px;
            gap: 3px;
        }

        .content-editable {
            min-height: 300px;
        }
    }

    .hidden {
        display: none;
    }
</style>

@if (_project == null) {
    <p>Loading...</p>
} else {
    <!-- 章追加モーダル -->
    @if (_showAddChapterModal) {
        <div class="modal-overlay" @onclick="CloseAddChapterModal">
            <div class="modal-content" @onclick:stopPropagation="true">
                <div class="modal-header">新しい章を追加</div>
                <div class="modal-body">
                    <input type="text" class="modal-input" @bind="_newChapterTitle" placeholder="章のタイトルを入力" maxlength="90" />
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn modal-btn-secondary" @onclick="CloseAddChapterModal">キャンセル</button>
                    <button class="modal-btn modal-btn-primary" @onclick="ConfirmAddChapter">追加</button>
                </div>
            </div>
        </div>
    }

    <!-- 話追加モーダル -->
    @if (_showAddSectionModal) {
        <div class="modal-overlay" @onclick="CloseAddSectionModal">
            <div class="modal-content" @onclick:stopPropagation="true">
                <div class="modal-header">新しい話を追加</div>
                <div class="modal-body">
                    <input type="text" class="modal-input" @bind="_newSectionTitle" placeholder="話のタイトルを入力" maxlength="90" />
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn modal-btn-secondary" @onclick="CloseAddSectionModal">キャンセル</button>
                    <button class="modal-btn modal-btn-primary" @onclick="ConfirmAddSection">追加</button>
                </div>
            </div>
        </div>
    }

    <!-- 章設定モーダル -->
    @if (_showChapterSettingsModal) {
        <div class="modal-overlay" @onclick="CloseChapterSettings">
            <div class="modal-content" @onclick:stopPropagation="true">
                <div class="modal-header">章の設定</div>
                <div class="modal-body">
                    <div class="modal-section">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">章のタイトル</label>
                        <input type="text" class="modal-input" @bind="_editingChapterTitle" maxlength="90" />
                    </div>
                    <div class="modal-section">
                        <button class="modal-btn modal-btn-danger" style="width: 100%;" @onclick="ShowDeleteChapterConfirm">章を削除</button>
                    </div>
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn modal-btn-secondary" @onclick="CloseChapterSettings">キャンセル</button>
                    <button class="modal-btn modal-btn-primary" @onclick="SaveChapterSettings">保存</button>
                </div>
            </div>
        </div>
    }

    <!-- 章削除確認モーダル -->
    @if (_showDeleteChapterConfirm) {
        <div class="modal-overlay" @onclick="CloseDeleteChapterConfirm">
            <div class="modal-content" @onclick:stopPropagation="true">
                <div class="modal-header">章の削除</div>
                <div class="modal-body">
                    <p>この章を削除してもよろしいですか？</p>
                    <p style="color: #dc3545; margin-top: 10px;">※この章に含まれるすべての話も削除されます。</p>
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn modal-btn-secondary" @onclick="CloseDeleteChapterConfirm">キャンセル</button>
                    <button class="modal-btn modal-btn-danger" @onclick="ConfirmDeleteChapter">削除</button>
                </div>
            </div>
        </div>
    }

    <!-- 話削除確認モーダル -->
    @if (_showDeleteSectionConfirm) {
        <div class="modal-overlay" @onclick="CloseDeleteSectionConfirm">
            <div class="modal-content" @onclick:stopPropagation="true">
                <div class="modal-header">話の削除</div>
                <div class="modal-body">
                    <p>この話を削除してもよろしいですか？</p>
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn modal-btn-secondary" @onclick="CloseDeleteSectionConfirm">キャンセル</button>
                    <button class="modal-btn modal-btn-danger" @onclick="ConfirmDeleteSection">削除</button>
                </div>
            </div>
        </div>
    }

    <!-- ルビ追加モーダル -->
    @if (_showRubyModal) {
        <div class="modal-overlay" @onclick="CloseRubyModal">
            <div class="modal-content" @onclick:stopPropagation="true">
                <div class="modal-header">@(_isEditingRuby ? "ルビを編集" : "ルビを追加")</div>
                <div class="modal-body">
                    <div class="modal-section">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">テキスト</label>
                        <input type="text" class="modal-input" @bind="_rubyBase" placeholder="漢字など" readonly="@(_hasSelectedText && !_isEditingRuby)" />
                    </div>
                    <div class="modal-section">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">ルビ</label>
                        <input type="text" class="modal-input" @bind="_rubyText" placeholder="ふりがな" />
                    </div>
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn modal-btn-secondary" @onclick="CloseRubyModal">キャンセル</button>
                    <button class="modal-btn modal-btn-primary" @onclick="ConfirmAddRuby">@(_isEditingRuby ? "更新" : "追加")</button>
                </div>
            </div>
        </div>
    }
    <!-- デスクトップビュー -->
    <div class="edit-container desktop-view">
        <!-- サイドバー -->
        <div class="sidebar">
            @if (_showCategoryView) {
                <div class="sidebar-header" @onclick="BackToCategoryView">
                    &lt; カテゴリ選択に戻る
                </div>
                <div class="chapter-view">
                    @if (_project.ProjectDataObject?.Scenario?.chapters == null || _project.ProjectDataObject.Scenario.chapters.Length == 0) {
                        <div class="empty-message">章がありません</div>
                    } else {
                        @for (int i = 0; i < _project.ProjectDataObject.Scenario.chapters.Length; i++) {
                            var chapterIndex = i;
                            var chapter = _project.ProjectDataObject.Scenario.chapters[i];
                            <div class="chapter-item" @key="@($"chapter-{chapterIndex}")">
                                <div class="chapter-header">
                                    <span class="toggle-icon" @onclick="() => ToggleChapter(chapterIndex)">
                                        @(_expandedChapters.Contains(chapterIndex) ? "▼" : "▶")
                                    </span>
                                    <span class="chapter-title" @onclick="() => ToggleChapter(chapterIndex)">
                                        @(string.IsNullOrEmpty(chapter.Title) ? $"Chapter {chapterIndex + 1}" : chapter.Title)
                                    </span>
                                    <button class="add-section-btn" @onclick="() => ShowAddSectionModal(chapterIndex)">+</button>
                                    <button class="settings-btn" @onclick="() => ShowChapterSettings(chapterIndex)">⚙</button>
                                </div>
                                @if (_expandedChapters.Contains(chapterIndex)) {
                                    <div class="sections-list">
                                        @if (chapter.Sections == null || chapter.Sections.Length == 0) {
                                            <div class="empty-message" style="padding: 10px 40px;">話がありません</div>
                                        } else {
                                            @for (int j = 0; j < chapter.Sections.Length; j++) {
                                                var sectionIndex = j;
                                                var section = chapter.Sections[j];
                                                <div class="section-item @(_selectedChapter == chapterIndex && _selectedSection == sectionIndex ? "active" : "")"
                                                     @key="@($"section-{chapterIndex}-{sectionIndex}")"
                                                     style="display: flex; justify-content: space-between; align-items: center;">
                                                    <span style="flex: 1; cursor: pointer; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; padding-right: 5px;" @onclick="() => SelectSection(chapterIndex, sectionIndex)">
                                                        @(string.IsNullOrEmpty(section.Title) ? $"Section {sectionIndex + 1}" : section.Title)
                                                    </span>
                                                    <button class="delete-section-btn" style="font-size: 14px; flex-shrink: 0;" @onclick="() => ShowDeleteSectionConfirm(chapterIndex, sectionIndex)">−</button>
                                                </div>
                                            }
                                        }
                                    </div>
                                }
                            </div>
                        }
                    }
                    <button class="add-chapter-btn" @onclick="ShowAddChapterModal">+ 章を追加</button>
                </div>
            } else {
                <div class="sidebar-header" @onclick="BackToProjectList">
                    &lt; 一覧に戻る
                </div>
                <div class="category-view">
                    <div class="category-item @(_currentCategory == "writing" ? "active" : "")" @onclick='() => SelectCategory("writing")'>
                        執筆
                    </div>
                    <div class="category-item" @onclick='() => SelectCategory("structure")'>
                        構成
                    </div>
                    <div class="category-item" @onclick='() => SelectCategory("materials")'>
                        資料
                    </div>
                </div>
            }
        </div>

        <!-- 編集エリア -->
        <div class="editor-area">
            @if (_selectedChapter >= 0 && _selectedSection >= 0 &&
                    _project.ProjectDataObject?.Scenario?.chapters != null &&
                    _selectedChapter < _project.ProjectDataObject.Scenario.chapters.Length &&
                    _project.ProjectDataObject.Scenario.chapters[_selectedChapter].Sections != null &&
                    _selectedSection < _project.ProjectDataObject.Scenario.chapters[_selectedChapter].Sections.Length) {

                var section = _project.ProjectDataObject.Scenario.chapters[_selectedChapter].Sections[_selectedSection];

                <div class="editor-header">
                    <div class="editor-title">
                        @(
                                        string.IsNullOrEmpty(
                                        _project.ProjectDataObject.Scenario.chapters[_selectedChapter].Title
                                        )
                                        ? $"Chapter {_selectedChapter + 1}"
                                        : _project.ProjectDataObject.Scenario.chapters[_selectedChapter].Title
                                        )
                </div>
                <input type="text" class="section-title-input" @bind="section.Title" @bind:event="oninput" @bind:after="AutoSave" placeholder="セクションタイトル" maxlength="90" />
            </div>

                <div class="editor-toolbar">
                    <button class="toolbar-btn" @onclick="Undo" title="Undo">←</button>
                    <button class="toolbar-btn" @onclick="Redo" title="Redo">→</button>
                    <div class="toolbar-separator"></div>
                    <button class="toolbar-btn @(_formatStates["bold"] ? "active" : "")" @onclick='() => ToggleFormat("bold")' title="太字"><b>B</b></button>
                    <button class="toolbar-btn @(_formatStates["italic"] ? "active" : "")" @onclick='() => ToggleFormat("italic")' title="斜体"><i>I</i></button>
                    <button class="toolbar-btn @(_formatStates["underline"] ? "active" : "")" @onclick='() => ToggleFormat("underline")' title="下線"><u>U</u></button>
                    <div class="toolbar-separator"></div>
                    <button class="toolbar-btn" @onclick="ShowRubyModal" title="ルビ">ルビ</button>
                    <div class="toolbar-separator"></div>
                    <button class="toolbar-btn" @onclick='() => ApplyFormat("p")'>本文</button>
                    <button class="toolbar-btn" @onclick='() => ApplyFormat("h1")'>H1</button>
                    <button class="toolbar-btn" @onclick='() => ApplyFormat("h2")'>H2</button>
                    <button class="toolbar-btn" @onclick='() => ApplyFormat("h3")'>H3</button>
                    <div class="toolbar-separator"></div>
                    <button class="toolbar-btn" @onclick="ClearFormat" title="書式をクリア">✕ クリア</button>
                </div>

                <div class="editor-content">
                    <div @key="@($"{_selectedChapter}-{_selectedSection}")"
                         id="content-editable"
                         class="content-editable"
                         contenteditable="true"
                         @oninput="OnContentInput"
                         @onkeydown="OnKeyDown">
                    </div>
                </div>
                } else {
                <div class="editor-content">
                    @if (_showCategoryView) {
                        <div class="empty-message" style="margin-top: 50px;">
                            左のサイドバーから編集する話を選択してください
                        </div>
                    } else {
                        <div class="empty-message" style="margin-top: 50px;">
                            左のサイドバーからカテゴリーを選択してください
                        </div>
                    }
                </div>
            }
        </div>
    </div>

    <!-- モバイルビュー -->
    <div class="mobile-view">
        @if (_mobileShowEditor) {
            @if (_selectedChapter >= 0 && _selectedSection >= 0 &&
                _project.ProjectDataObject?.Scenario?.chapters != null &&
                _selectedChapter < _project.ProjectDataObject.Scenario.chapters.Length &&
                _project.ProjectDataObject.Scenario.chapters[_selectedChapter].Sections != null &&
                _selectedSection < _project.ProjectDataObject.Scenario.chapters[_selectedChapter].Sections.Length) {

                var section = _project.ProjectDataObject.Scenario.chapters[_selectedChapter].Sections[_selectedSection];

                <div class="mobile-editor">
                    <div class="mobile-editor-header">
                        <button class="back-btn" @onclick="BackToList">&lt;</button>
                        <div class="mobile-editor-title">
                            @(
                                            string.IsNullOrEmpty(
                                            _project.ProjectDataObject.Scenario.chapters[_selectedChapter].Title
                                            )
                                            ? $"Chapter {_selectedChapter + 1}"
                                            : _project.ProjectDataObject.Scenario.chapters[_selectedChapter].Title
                                            )
                        </div>
                    </div>

                    <div style="padding: 10px; border-bottom: 1px solid #ddd;">
                        <input type="text" class="section-title-input" @bind="section.Title" @bind:event="oninput" @bind:after="AutoSave" placeholder="セクションタイトル" maxlength="90" />
                    </div>

                    <div class="editor-toolbar">
                        <button class="toolbar-btn" @onclick="Undo">←</button>
                        <button class="toolbar-btn" @onclick="Redo">→</button>
                        <div class="toolbar-separator"></div>
                        <button class="toolbar-btn @(_formatStates["bold"] ? "active" : "")" @onclick='() => ToggleFormat("bold")'><b>B</b></button>
                        <button class="toolbar-btn @(_formatStates["italic"] ? "active" : "")" @onclick='() => ToggleFormat("italic")'><i>I</i></button>
                        <button class="toolbar-btn @(_formatStates["underline"] ? "active" : "")" @onclick='() => ToggleFormat("underline")'><u>U</u></button>
                        <div class="toolbar-separator"></div>
                        <button class="toolbar-btn" @onclick="ShowRubyModal" style="font-size: 11px;">ルビ</button>
                        <div class="toolbar-separator"></div>
                        <button class="toolbar-btn" @onclick='() => ApplyFormat("p")'>本文</button>
                        <button class="toolbar-btn" @onclick='() => ApplyFormat("h1")'>H1</button>
                        <button class="toolbar-btn" @onclick='() => ApplyFormat("h2")'>H2</button>
                        <button class="toolbar-btn" @onclick='() => ApplyFormat("h3")'>H3</button>
                        <div class="toolbar-separator"></div>
                        <button class="toolbar-btn" @onclick="ClearFormat" style="font-size: 11px;">✕</button>
                    </div>

                    <div style="flex: 1; overflow-y: auto; padding: 10px;">
                        <div id="content-editable-mobile"
                             class="content-editable"
                             contenteditable="true"
                             @oninput="OnContentInput"
                             @onkeydown="OnKeyDown">
                        </div>
                    </div>
                </div>
        }
        } else {
            <div class="mobile-list">
                <div class="mobile-header">
                    <button class="back-btn" @onclick="BackToProjectList">&lt;</button>
                    <div class="mobile-editor-title">執筆</div>
                </div>
                @if (_project.ProjectDataObject?.Scenario?.chapters == null || _project.ProjectDataObject.Scenario.chapters.Length == 0) {
                    <div class="empty-message">章がありません</div>
                } else {
                    @for (int i = 0; i < _project.ProjectDataObject.Scenario.chapters.Length; i++) {
                        var chapterIndex = i;
                        var chapter = _project.ProjectDataObject.Scenario.chapters[i];
                        <div class="chapter-item" @key="@($"mobile-chapter-{chapterIndex}")">
                            <div class="chapter-header">
                                <span class="toggle-icon" @onclick="() => ToggleChapter(chapterIndex)">
                                    @(_expandedChapters.Contains(chapterIndex) ? "▼" : "▶")
                                </span>
                                <span class="chapter-title" @onclick="() => ToggleChapter(chapterIndex)">
                                    @(string.IsNullOrEmpty(chapter.Title) ? $"Chapter {chapterIndex + 1}" : chapter.Title)
                                </span>
                                <button class="add-section-btn" @onclick="() => ShowAddSectionModal(chapterIndex)">+</button>
                                <button class="settings-btn" @onclick="() => ShowChapterSettings(chapterIndex)">⚙</button>
                            </div>
                            @if (_expandedChapters.Contains(chapterIndex)) {
                                <div class="sections-list">
                                    @if (chapter.Sections == null || chapter.Sections.Length == 0) {
                                        <div class="empty-message" style="padding: 10px 40px;">話がありません</div>
                                    } else {
                                        @for (int j = 0; j < chapter.Sections.Length; j++) {
                                            var sectionIndex = j;
                                            var section = chapter.Sections[j];
                                            <div class="section-item"
                                                 @key="@($"mobile-section-{chapterIndex}-{sectionIndex}")"
                                                 style="display: flex; justify-content: space-between; align-items: center;">
                                                <span style="flex: 1; cursor: pointer; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; padding-right: 5px;" @onclick="() => SelectSectionMobile(chapterIndex, sectionIndex)">
                                                    @(string.IsNullOrEmpty(section.Title) ? $"Section {sectionIndex + 1}" : section.Title)
                                                </span>
                                                <button class="delete-section-btn" style="font-size: 14px; flex-shrink: 0;" @onclick="() => ShowDeleteSectionConfirm(chapterIndex, sectionIndex)">−</button>
                                            </div>
                                        }
                                    }
                                </div>
                            }
                        </div>
                    }
                }
                <button class="add-chapter-btn" @onclick="ShowAddChapterModal">+ 章を追加</button>
            </div>
        }
    </div>
}

@code {
    [Parameter]
    public int id { get; set; }

    private Project? _project;
    private bool _showCategoryView = true;
    private string _currentCategory = "writing";
    private HashSet<int> _expandedChapters = new HashSet<int>();
    private int _selectedChapter = -1;
    private int _selectedSection = -1;
    private bool _mobileShowEditor = false;
    private static Dictionary<string, Edit> _instances = new Dictionary<string, Edit>();
    private string _instanceId = Guid.NewGuid().ToString();
    private Dictionary<string, bool> _formatStates = new Dictionary<string, bool>
    {
        { "bold", false },
        { "italic", false },
        { "underline", false }
    };
    private System.Threading.Timer? _autoSaveTimer;
    private SemaphoreSlim _saveSemaphore = new SemaphoreSlim(1, 1);

    protected override async Task OnInitializedAsync() {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        var appUser = await UserManager.GetUserAsync(user);
        var userId = appUser.Id;

        _project = await DbFactory
            .CreateDbContext()
            .Projects
            .Where(x => x.Id == id && x.UserId == userId)
            .FirstOrDefaultAsync();

        if (_project == null) {
            Nav.NavigateTo("/projects");
        }
    }

    protected override void OnInitialized() {
        base.OnInitialized();
        _instances[_instanceId] = this;
    }

    public void Dispose() {
        _autoSaveTimer?.Dispose();
        _saveSemaphore?.Dispose();
        _instances.Remove(_instanceId);
    }

    private int _lastRenderedChapter = -1;
    private int _lastRenderedSection = -1;

    private string _currentContentCache = "";
    private bool _isResizing = false;

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            await JSRuntime.InvokeVoidAsync("eval", $@"
            window.addEventListener('formatStateChanged', function(e) {{
                DotNet.invokeMethodAsync('StoryDesignSupportWebApp', 'UpdateFormatStates', '{_instanceId}', e.detail);
            }});

            // リサイズ検知
            let resizeTimer;
            window.addEventListener('resize', function() {{
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(function() {{
                    DotNet.invokeMethodAsync('StoryDesignSupportWebApp', 'OnWindowResize', '{_instanceId}', window.innerWidth);
                }}, 300);
            }});

            // ヘッダーの高さに応じてコンテナの高さを調整
            function adjustContainerHeight() {{
                const topRow = document.querySelector('.top-row');
                const desktopContainer = document.querySelector('.edit-container.desktop-view');
                const mobileContainer = document.querySelector('.mobile-view');
                const mobileView = document.querySelector('.mobile-list');
                const mobileEditor = document.querySelector('.mobile-editor');

                if (topRow) {{
                    const isCollapsed = topRow.classList.contains('collapsed');
                    const height = isCollapsed ? 'calc(100vh - 2rem)' : 'calc(100vh - 5.5rem)';

                    if (desktopContainer) {{
                        desktopContainer.style.height = height;
                    }}
                    if (mobileContainer) {{
                        mobileContainer.style.height = height;
                    }}
                    if (mobileView) {{
                        mobileView.style.height = height;
                    }}
                    if (mobileEditor) {{
                        mobileEditor.style.height = height;
                    }}
                }}
            }}

            // 初回調整
            adjustContainerHeight();

            // MutationObserverでヘッダーの変更を監視
            const observer = new MutationObserver(adjustContainerHeight);
            const topRow = document.querySelector('.top-row');
            if (topRow) {{
                observer.observe(topRow, {{ attributes: true, attributeFilter: ['class'] }});
            }}
        ");
        }

        // セクションが変更された場合、またはリサイズ時
        bool sectionChanged = (_selectedChapter != _lastRenderedChapter || _selectedSection != _lastRenderedSection);
        bool needsUpdate = sectionChanged || _isResizing;

        if (needsUpdate &&
            _selectedChapter >= 0 && _selectedSection >= 0 &&
            _project?.ProjectDataObject?.Scenario?.chapters != null &&
            _selectedChapter < _project.ProjectDataObject.Scenario.chapters.Length &&
            _project.ProjectDataObject.Scenario.chapters[_selectedChapter].Sections != null &&
            _selectedSection < _project.ProjectDataObject.Scenario.chapters[_selectedChapter].Sections.Length) {

            var section = _project.ProjectDataObject.Scenario.chapters[_selectedChapter].Sections[_selectedSection];

            // 両方のエディタに内容を設定
            await JSRuntime.InvokeVoidAsync("setEditableContent", "content-editable", section.Text ?? "");
            await JSRuntime.InvokeVoidAsync("setEditableContent", "content-editable-mobile", section.Text ?? "");

            _lastRenderedChapter = _selectedChapter;
            _lastRenderedSection = _selectedSection;
            _isResizing = false;
        }
    }

    [JSInvokable("UpdateFormatStates")]
    public static void UpdateFormatStates(string instanceId, Dictionary<string, bool> states) {
        if (!_instances.TryGetValue(instanceId, out var instance) || instance == null) {
            return;
        }

        instance.InvokeAsync(() => {
            if (states.ContainsKey("bold")) {
                instance._formatStates["bold"] = states["bold"];
            }
            if (states.ContainsKey("italic")) {
                instance._formatStates["italic"] = states["italic"];
            }
            if (states.ContainsKey("underline")) {
                instance._formatStates["underline"] = states["underline"];
            }
            instance.StateHasChanged();
        });
    }

    private async Task BackToCategoryView() {
        // 現在のセクションを保存
        if (_selectedChapter >= 0 && _selectedSection >= 0) {
            await SaveContent();
            await AutoSave();
        }

        _showCategoryView = false;
        _selectedChapter = -1;
        _selectedSection = -1;
        _lastRenderedChapter = -1;
        _lastRenderedSection = -1;
        _mobileShowEditor = false;

        StateHasChanged();
    }

    private async Task SelectCategory(string category) {
        // 現在のセクションを保存
        if (_selectedChapter >= 0 && _selectedSection >= 0) {
            await SaveContent();
            await AutoSave();
        }

        _currentCategory = category;
        if (category == "writing") {
            _showCategoryView = true;
        } else if (category == "structure") {
            NavigateToStructure(id);
        } else if (category == "materials") {
            NavigateToMaterials(id);
        }

        // 編集画面を閉じる
        _selectedChapter = -1;
        _selectedSection = -1;
        _lastRenderedChapter = -1;
        _lastRenderedSection = -1;
        _mobileShowEditor = false;

        StateHasChanged();
    }

    private void NavigateToStructure(int id) {
        Nav.NavigateTo($"/projects/edit/{id}/structure");
    }

    private void NavigateToMaterials(int id) {
        Nav.NavigateTo($"/projects/edit/{id}/materials");
    }

    private void ToggleChapter(int chapterIndex) {
        if (_expandedChapters.Contains(chapterIndex)) {
            _expandedChapters.Remove(chapterIndex);
        } else {
            _expandedChapters.Add(chapterIndex);
        }
    }

    private async void SelectSection(int chapterIndex, int sectionIndex) {
        // 現在のセクションを保存
        if (_selectedChapter >= 0 && _selectedSection >= 0) {
            await SaveContent();
            await AutoSave();
        }

        _selectedChapter = chapterIndex;
        _selectedSection = sectionIndex;
        ResetFormatStates();

        // 強制的に再レンダリング
        _lastRenderedChapter = -1;
        _lastRenderedSection = -1;

        StateHasChanged();
    }

    private async void SelectSectionMobile(int chapterIndex, int sectionIndex) {
        // 現在のセクションを保存
        if (_selectedChapter >= 0 && _selectedSection >= 0) {
            await SaveContent();
            await AutoSave();
        }

        _selectedChapter = chapterIndex;
        _selectedSection = sectionIndex;
        _mobileShowEditor = true;
        ResetFormatStates();

        // 強制的に再レンダリング
        _lastRenderedChapter = -1;
        _lastRenderedSection = -1;

        StateHasChanged();
    }

    private async void BackToList() {
        // 保存してからリストに戻る
        await SaveContent();
        await AutoSave();
        _mobileShowEditor = false;
        _selectedChapter = -1;
        _selectedSection = -1;
        _lastRenderedChapter = -1;
        _lastRenderedSection = -1;
        StateHasChanged();
    }

    private async Task ToggleFormat(string format) {
        _formatStates[format] = !_formatStates[format];
        var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";
        await JSRuntime.InvokeVoidAsync("toggleFormat", elementId, format, _formatStates[format]);
    }

    private async Task ApplyFormat(string format) {
        var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";
        await JSRuntime.InvokeVoidAsync("applyBlockFormat", elementId, format);
    }

    private async Task ClearFormat() {
        var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";
        await JSRuntime.InvokeVoidAsync("clearFormat", elementId);
        ResetFormatStates();
    }

    private void ResetFormatStates() {
        _formatStates["bold"] = false;
        _formatStates["italic"] = false;
        _formatStates["underline"] = false;
    }

    private async Task OnContentInput() {
        await SaveContent();
        ScheduleAutoSave();
    }

    private async Task OnKeyDown() {
        // キーボード入力時の処理
    }

    private async Task Undo() {
        var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";
        await JSRuntime.InvokeVoidAsync("undoEditor", elementId);
    }

    private async Task Redo() {
        var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";
        await JSRuntime.InvokeVoidAsync("redoEditor", elementId);
    }

    private async Task BackToProjectList() {
        if (_selectedChapter >= 0 && _selectedSection >= 0) {
            await SaveContent();
        }

        await using var db = DbFactory.CreateDbContext();
        db.Projects.Update(_project);
        await db.SaveChangesAsync();   // ← ここで確定

        _selectedChapter = -1;
        _selectedSection = -1;
        _lastRenderedChapter = -1;
        _lastRenderedSection = -1;

        Nav.NavigateTo("/projects");
    }

    private async Task SaveContent() {
        try {
            string content = "";

            // 現在表示されているエディタから内容を取得
            if (_mobileShowEditor) {
                content = await JSRuntime.InvokeAsync<string>("getEditableContent", "content-editable-mobile");
            } else {
                content = await JSRuntime.InvokeAsync<string>("getEditableContent", "content-editable");
            }

            if (_selectedChapter >= 0 && _selectedSection >= 0 &&
                _project?.ProjectDataObject?.Scenario?.chapters != null &&
                _selectedChapter < _project.ProjectDataObject.Scenario.chapters.Length &&
                _project.ProjectDataObject.Scenario.chapters[_selectedChapter].Sections != null &&
                _selectedSection < _project.ProjectDataObject.Scenario.chapters[_selectedChapter].Sections.Length) {

                _project.ProjectDataObject.Scenario.chapters[_selectedChapter].Sections[_selectedSection].Text = content;
                _currentContentCache = content;
            }
        }
        catch (Exception ex) {
            Console.WriteLine($"SaveContent error: {ex.Message}");
        }
    }

    private void ScheduleAutoSave() {
        _autoSaveTimer?.Dispose();
        _autoSaveTimer = new System.Threading.Timer(async _ => {
            await InvokeAsync(async () => {
                await AutoSave();
            });
        }, null, 1000, Timeout.Infinite);
    }

    private async Task AutoSave() {
        // 既に保存処理が実行中なら待機
        if (!await _saveSemaphore.WaitAsync(0)) {
            return; // 保存中なら今回はスキップ
        }

        try {
            if (_project != null) {
                _project.UpdatedAt = DateTime.UtcNow;
                await using var db = DbFactory.CreateDbContext();
                db.Projects.Update(_project);
                await db.SaveChangesAsync();
            }
        }
        catch (Exception ex) {
            // エラーログ（必要に応じて）
            Console.WriteLine($"AutoSave error: {ex.Message}");
        }
        finally {
            _saveSemaphore.Release();
        }
    }

    // モーダル関連の状態
    private bool _showAddChapterModal = false;
    private bool _showAddSectionModal = false;
    private bool _showChapterSettingsModal = false;
    private bool _showDeleteChapterConfirm = false;
    private string _newChapterTitle = "";
    private string _newSectionTitle = "";
    private string _editingChapterTitle = "";
    private int _editingChapterIndex = -1;
    private int _addingSectionToChapterIndex = -1;
    private bool _showDeleteSectionConfirm = false;
    private int _deletingSectionChapterIndex = -1;
    private int _deletingSectionIndex = -1;
    private bool _showRubyModal = false;
    private string _rubyText = "";
    private string _rubyBase = "";
    private bool _isEditingRuby = false;
    private bool _hasSelectedText = false;

    // 章追加モーダル
    private void ShowAddChapterModal() {
        var chapterCount = _project?.ProjectDataObject?.Scenario?.chapters?.Length ?? 0;
        _newChapterTitle = $"第{chapterCount + 1}章";
        _showAddChapterModal = true;
    }

    private void CloseAddChapterModal() {
        _showAddChapterModal = false;
        _newChapterTitle = "";
    }

    private async Task ConfirmAddChapter() {
        if (_project?.ProjectDataObject?.Scenario == null) return;

        var newChapter = new Chapter {
            Title = _newChapterTitle
        };

        if (_project.ProjectDataObject.Scenario.chapters == null) {
            _project.ProjectDataObject.Scenario.chapters = new[] { newChapter };
        } else {
            var chapterList = _project.ProjectDataObject.Scenario.chapters.ToList();
            chapterList.Add(newChapter);
            _project.ProjectDataObject.Scenario.chapters = chapterList.ToArray();
        }

        _project.UpdatedAt = DateTime.UtcNow;
        await using var db = DbFactory.CreateDbContext();
        db.Projects.Update(_project);
        await db.SaveChangesAsync();

        CloseAddChapterModal();
    }

    // 話追加モーダル
    private void ShowAddSectionModal(int chapterIndex) {
        _addingSectionToChapterIndex = chapterIndex;
        var chapter = _project?.ProjectDataObject?.Scenario?.chapters?[chapterIndex];
        var sectionCount = chapter?.Sections?.Length ?? 0;
        _newSectionTitle = $"第{sectionCount + 1}話";
        _showAddSectionModal = true;
    }

    private void CloseAddSectionModal() {
        _showAddSectionModal = false;
        _newSectionTitle = "";
        _addingSectionToChapterIndex = -1;
    }

    private async Task ConfirmAddSection() {
        if (_project?.ProjectDataObject?.Scenario?.chapters == null) return;
        if (_addingSectionToChapterIndex < 0 || _addingSectionToChapterIndex >= _project.ProjectDataObject.Scenario.chapters.Length) return;

        var chapter = _project.ProjectDataObject.Scenario.chapters[_addingSectionToChapterIndex];
        var newSection = new Section {
            Title = _newSectionTitle,
            Text = ""
        };

        if (chapter.Sections == null) {
            chapter.Sections = new[] { newSection };
        } else {
            var sectionList = chapter.Sections.ToList();
            sectionList.Add(newSection);
            chapter.Sections = sectionList.ToArray();
        }

        _project.UpdatedAt = DateTime.UtcNow;
        await using var db = DbFactory.CreateDbContext();
        db.Projects.Update(_project);
        await db.SaveChangesAsync();

        CloseAddSectionModal();
    }

    // 章設定モーダル
    private void ShowChapterSettings(int chapterIndex) {
        _editingChapterIndex = chapterIndex;
        var chapter = _project?.ProjectDataObject?.Scenario?.chapters?[chapterIndex];
        _editingChapterTitle = chapter?.Title ?? "";
        _showChapterSettingsModal = true;
    }

    private void CloseChapterSettings() {
        _showChapterSettingsModal = false;
        _editingChapterTitle = "";
        _editingChapterIndex = -1;
    }

    private async Task SaveChapterSettings() {
        if (_project?.ProjectDataObject?.Scenario?.chapters == null) return;
        if (_editingChapterIndex < 0 || _editingChapterIndex >= _project.ProjectDataObject.Scenario.chapters.Length) return;

        _project.ProjectDataObject.Scenario.chapters[_editingChapterIndex].Title = _editingChapterTitle;

        _project.UpdatedAt = DateTime.UtcNow;
        await using var db = DbFactory.CreateDbContext();
        db.Projects.Update(_project);
        await db.SaveChangesAsync();

        CloseChapterSettings();
    }

    // 章削除
    private void ShowDeleteChapterConfirm() {
        _showDeleteChapterConfirm = true;
    }

    private void CloseDeleteChapterConfirm() {
        _showDeleteChapterConfirm = false;
    }

    private async Task ConfirmDeleteChapter() {
        if (_project?.ProjectDataObject?.Scenario?.chapters == null) return;
        if (_editingChapterIndex < 0 || _editingChapterIndex >= _project.ProjectDataObject.Scenario.chapters.Length) return;

        var chapterList = _project.ProjectDataObject.Scenario.chapters.ToList();
        chapterList.RemoveAt(_editingChapterIndex);
        _project.ProjectDataObject.Scenario.chapters = chapterList.ToArray();

        // 削除した章を選択していた場合はリセット
        if (_selectedChapter == _editingChapterIndex) {
            _selectedChapter = -1;
            _selectedSection = -1;
            _lastRenderedChapter = -1;
            _lastRenderedSection = -1;
        } else if (_selectedChapter > _editingChapterIndex) {
            // 削除した章より後ろの章を選択していた場合はインデックスを調整
            _selectedChapter--;
        }

        _project.UpdatedAt = DateTime.UtcNow;
        await using var db = DbFactory.CreateDbContext();
        db.Projects.Update(_project);
        await db.SaveChangesAsync();

        CloseDeleteChapterConfirm();
        CloseChapterSettings();
    }

    private void ShowDeleteSectionConfirm(int chapterIndex, int sectionIndex) {
        _deletingSectionChapterIndex = chapterIndex;
        _deletingSectionIndex = sectionIndex;
        _showDeleteSectionConfirm = true;
    }

    private void CloseDeleteSectionConfirm() {
        _showDeleteSectionConfirm = false;
        _deletingSectionChapterIndex = -1;
        _deletingSectionIndex = -1;
    }

    private async Task ConfirmDeleteSection() {
        if (_project?.ProjectDataObject?.Scenario?.chapters == null) return;
        if (_deletingSectionChapterIndex < 0 || _deletingSectionChapterIndex >= _project.ProjectDataObject.Scenario.chapters.Length) return;

        var chapter = _project.ProjectDataObject.Scenario.chapters[_deletingSectionChapterIndex];
        if (chapter.Sections == null || _deletingSectionIndex < 0 || _deletingSectionIndex >= chapter.Sections.Length) return;

        var sectionList = chapter.Sections.ToList();
        sectionList.RemoveAt(_deletingSectionIndex);
        chapter.Sections = sectionList.ToArray();

        // 削除した話を選択していた場合はリセット
        if (_selectedChapter == _deletingSectionChapterIndex && _selectedSection == _deletingSectionIndex) {
            _selectedChapter = -1;
            _selectedSection = -1;
            _lastRenderedChapter = -1;
            _lastRenderedSection = -1;
            _mobileShowEditor = false;
        } else if (_selectedChapter == _deletingSectionChapterIndex && _selectedSection > _deletingSectionIndex) {
            // 削除した話より後ろの話を選択していた場合はインデックスを調整
            _selectedSection--;
        }

        _project.UpdatedAt = DateTime.UtcNow;
        await using var db = DbFactory.CreateDbContext();
        db.Projects.Update(_project);
        await db.SaveChangesAsync();

        CloseDeleteSectionConfirm();
    }

    //ルビモーダル
    private async Task ShowRubyModal() {
        var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";

        // カーソル位置を保存（editableエリア内でない場合は末尾に移動）
        await JSRuntime.InvokeVoidAsync("saveSelectionForRuby", elementId);

        var rubyData = await JSRuntime.InvokeAsync<string[]>("checkRubySelection", elementId);

        if (rubyData != null && rubyData.Length == 2) {
            // ルビ要素を編集
            _isEditingRuby = true;
            _hasSelectedText = false;
            _rubyBase = rubyData[0];
            _rubyText = rubyData[1];
        } else {
            // 新規追加
            _isEditingRuby = false;
            var selectedText = await JSRuntime.InvokeAsync<string>("getSelectedText", elementId);

            if (!string.IsNullOrEmpty(selectedText)) {
                // 選択範囲がある場合
                _hasSelectedText = true;
                _rubyBase = selectedText;
                _rubyText = "";
            } else {
                // カーソル位置に挿入
                _hasSelectedText = false;
                _rubyBase = "";
                _rubyText = "";
            }
        }

        _showRubyModal = true;
    }

    private void CloseRubyModal() {
        _showRubyModal = false;
        _rubyText = "";
        _rubyBase = "";
        _isEditingRuby = false;
        _hasSelectedText = false;
    }

    private async Task ConfirmAddRuby() {
        if (string.IsNullOrEmpty(_rubyText) || string.IsNullOrEmpty(_rubyBase)) {
            CloseRubyModal();
            return;
        }

        var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";

        // 保存した選択範囲を復元
        await JSRuntime.InvokeVoidAsync("restoreSelection", elementId);

        if (_isEditingRuby) {
            await JSRuntime.InvokeVoidAsync("updateRuby", elementId, _rubyBase, _rubyText);
        } else {
            await JSRuntime.InvokeVoidAsync("insertRuby", elementId, _rubyBase, _rubyText, _hasSelectedText);
        }

        CloseRubyModal();
    }

    [JSInvokable("OnWindowResize")]
    public static async Task OnWindowResize(string instanceId, int width) {
        if (!_instances.TryGetValue(instanceId, out var instance)) return;

        await instance.InvokeAsync(async () => {
            bool isMobile = width <= 768;

            // ★ モバイル → PC に切り替わる瞬間
            if (!isMobile && instance._mobileShowEditor) {
                // 現在のモバイルエディタの内容を保存
                await instance.SaveContent();
                instance._mobileShowEditor = false;
                // 強制的に再レンダリングフラグを立てる
                instance._isResizing = true;
            }
            // ★ PC → モバイルに切り替わる瞬間（セクションが選択されている場合）
            else if (isMobile && !instance._mobileShowEditor &&
                     instance._selectedChapter >= 0 && instance._selectedSection >= 0) {
                await instance.SaveContent();
                instance._mobileShowEditor = true;
                instance._isResizing = true;
            }

            instance.StateHasChanged();
        });
    }
}

<script>
    (function() {
        if (window.editorScriptLoaded) return;
        window.editorScriptLoaded = true;

        let currentFormat = {
            bold: false,
            italic: false,
            underline: false
        };

        window.setEditableContent = function(elementId, content) {
            const element = document.getElementById(elementId);
            if (!element) return; // 要素が存在しない場合は何もしない

            if (element.innerHTML !== (content || '')) {
                element.innerHTML = content || '';

                const selection = window.getSelection();
                const range = document.createRange();

                if (element.childNodes.length > 0) {
                    range.setStart(element.childNodes[0], 0);
                    range.collapse(true);
                } else {
                    range.selectNodeContents(element);
                    range.collapse(true);
                }

                selection.removeAllRanges();
                selection.addRange(range);
            }
        };

        window.getEditableContent = function(elementId) {
            const element = document.getElementById(elementId);
            return element ? element.innerHTML : '';
        };

        // 選択状態とフォーカス状態の変更を監視
        document.addEventListener('selectionchange', function() {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                updateFormatStates();
            }
        });

        function updateFormatStates() {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;

            const range = selection.getRangeAt(0);

            if (selection.isCollapsed) {
                // カーソル位置の書式を確認
                const node = range.startContainer;
                const parentElement = node.nodeType === 3 ? node.parentElement : node;

                // 親要素を辿って書式を確認
                currentFormat.bold = hasParentTag(parentElement, 'B') || hasParentTag(parentElement, 'STRONG');
                currentFormat.italic = hasParentTag(parentElement, 'I') || hasParentTag(parentElement, 'EM');
                currentFormat.underline = hasParentTag(parentElement, 'U');
                notifyFormatStates();
            } else {
                // 選択範囲の書式を確認
                const parentElement = range.commonAncestorContainer.nodeType === 3
                    ? range.commonAncestorContainer.parentElement
                    : range.commonAncestorContainer;

                currentFormat.bold = document.queryCommandState('bold') || hasParentTag(parentElement, 'B') || hasParentTag(parentElement, 'STRONG');
                currentFormat.italic = document.queryCommandState('italic') || hasParentTag(parentElement, 'I') || hasParentTag(parentElement, 'EM');
                currentFormat.underline = document.queryCommandState('underline') || hasParentTag(parentElement, 'U');
                notifyFormatStates();
            }
        }

        function hasParentTag(element, tagName) {
            while (element && element.nodeName !== 'DIV' && element.getAttribute('contenteditable') !== 'true') {
                if (element.nodeName === tagName) return true;
                element = element.parentElement;
            }
            return false;
        }

        function notifyFormatStates() {
            window.dispatchEvent(new CustomEvent('formatStateChanged', {
                detail: currentFormat
            }));
        }

        window.toggleFormat = function(elementId, format, isActive) {
            const element = document.getElementById(elementId);
            if (!element) return;

            element.focus();
            const selection = window.getSelection();

            if (selection.rangeCount > 0 && !selection.isCollapsed) {
                // テキストが選択されている場合
                document.execCommand(format, false, null);

                // 選択を解除
                setTimeout(() => {
                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        range.collapse(false);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                    // 書式状態を更新
                    updateFormatStates();
                }, 10);
            } else {
                // 選択されていない場合
                currentFormat[format] = isActive;
                document.execCommand(format, false, null);
                notifyFormatStates();
            }
        };

        window.applyBlockFormat = function(elementId, format) {
            const element = document.getElementById(elementId);
            if (!element) return;

            element.focus();
            const selection = window.getSelection();

            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);

                if (selection.isCollapsed) {
                    // カーソル位置のブロックを変更
                    const currentNode = range.startContainer;
                    let blockElement = currentNode.nodeType === 3 ? currentNode.parentElement : currentNode;

                    // contenteditable要素に到達するまで親を辿る
                    while (blockElement && blockElement !== element && !isBlockElement(blockElement)) {
                        blockElement = blockElement.parentElement;
                    }

                    if (blockElement === element) {
                        // ルート要素の場合、新しいブロックを作成
                        const newElement = document.createElement(format);
                        newElement.innerHTML = '<br>';
                        newElement.style.lineHeight = ''; // スタイルをクリア
                        element.appendChild(newElement);

                        const newRange = document.createRange();
                        newRange.setStart(newElement, 0);
                        newRange.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(newRange);
                    } else if (blockElement) {
                        // カーソル位置を保存
                        const offset = getCaretOffset(blockElement, range);

                        const newElement = document.createElement(format);
                        newElement.innerHTML = blockElement.innerHTML || '<br>';
                        newElement.style.lineHeight = ''; // インラインスタイルをクリア
                        blockElement.parentNode.replaceChild(newElement, blockElement);

                        // カーソル位置を復元
                        restoreCaretOffset(newElement, offset);
                    }
                } else {
                    // 選択範囲がある場合
                    document.execCommand('formatBlock', false, '<' + format + '>');

                    setTimeout(() => {
                        // 適用された要素のインラインスタイルをクリア
                        const currentNode = selection.getRangeAt(0).startContainer;
                        let blockElement = currentNode.nodeType === 3 ? currentNode.parentElement : currentNode;

                        while (blockElement && blockElement !== element && !isBlockElement(blockElement)) {
                            blockElement = blockElement.parentElement;
                        }

                        if (blockElement && blockElement !== element) {
                            blockElement.style.lineHeight = '';
                        }

                        if (selection.rangeCount > 0) {
                            const range = selection.getRangeAt(0);
                            range.collapse(false);
                            selection.removeAllRanges();
                            selection.addRange(range);
                        }
                        element.focus();
                    }, 10);
                }
            }
        };

        function isBlockElement(element) {
            const blockTags = ['P', 'DIV', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'BLOCKQUOTE', 'PRE'];
            return blockTags.includes(element.nodeName);
        }

        function getCaretOffset(element, range) {
            const preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(element);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            return preCaretRange.toString().length;
        }

        function restoreCaretOffset(element, offset) {
            const selection = window.getSelection();
            const range = document.createRange();

            let currentPos = 0;
            let found = false;

            function searchNode(node) {
                if (found) return;

                if (node.nodeType === 3) {
                    const nodeLength = node.textContent.length;
                    if (currentPos + nodeLength >= offset) {
                        range.setStart(node, offset - currentPos);
                        range.collapse(true);
                        found = true;
                        return;
                    }
                    currentPos += nodeLength;
                } else if (node.nodeName === 'BR') {
                    currentPos += 1;
                    if (currentPos >= offset) {
                        range.setStartAfter(node);
                        range.collapse(true);
                        found = true;
                        return;
                    }
                } else {
                    for (let i = 0; i < node.childNodes.length; i++) {
                        searchNode(node.childNodes[i]);
                        if (found) return;
                    }
                }
            }

            searchNode(element);

            if (found) {
                selection.removeAllRanges();
                selection.addRange(range);
            } else {
                // 位置が見つからない場合は最後に設定
                range.selectNodeContents(element);
                range.collapse(false);
                selection.removeAllRanges();
                selection.addRange(range);
            }

            element.focus();
        }

        // 選択範囲を保存する変数
        let savedSelection = null;

        window.saveSelection = function(elementId) {
            // この関数は他の用途で使われている可能性があるので残す
            const element = document.getElementById(elementId);
            if (!element) return;

            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                savedSelection = {
                    range: selection.getRangeAt(0).cloneRange(),
                    elementId: elementId
                };
            }
        };

        window.restoreSelection = function(elementId) {
            const element = document.getElementById(elementId);
            if (!element || !savedSelection || savedSelection.elementId !== elementId) return;

            element.focus();
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(savedSelection.range);
        };

        window.getSelectedText = function(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return '';

            const selection = window.getSelection();
            if (selection.rangeCount > 0 && !selection.isCollapsed) {
                const range = selection.getRangeAt(0);
                // ruby要素内のテキストを除外
                const fragment = range.cloneContents();
                const temp = document.createElement('div');
                temp.appendChild(fragment);

                // rt要素を削除
                const rtElements = temp.querySelectorAll('rt');
                rtElements.forEach(rt => rt.remove());

                return temp.textContent;
            }
            return '';
        };

        window.insertRuby = function(elementId, baseText, rubyText, hasSelectedText) {
            const element = document.getElementById(elementId);
            if (!element) return;

            element.focus();
            const selection = window.getSelection();

            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);

                // 削除前の位置情報を保存
                let insertPosition = null;

                // 選択範囲内の既存ruby要素を削除
                if (!selection.isCollapsed) {
                    const fragment = range.cloneContents();
                    const tempDiv = document.createElement('div');
                    tempDiv.appendChild(fragment);

                    if (tempDiv.querySelector('ruby')) {
                        // ruby要素が含まれる場合、実際のDOMから削除
                        const actualRange = range.cloneRange();

                        // 挿入位置を記録（範囲の開始位置）
                        insertPosition = {
                            container: actualRange.startContainer,
                            offset: actualRange.startOffset
                        };

                        // 範囲内のすべてのruby要素を取得
                        const rubysToDelete = [];

                        const walker = document.createTreeWalker(
                            actualRange.commonAncestorContainer,
                            NodeFilter.SHOW_ELEMENT,
                            {
                                acceptNode: function(node) {
                                    if (node.nodeName === 'RUBY' && actualRange.intersectsNode(node)) {
                                        return NodeFilter.FILTER_ACCEPT;
                                    }
                                    return NodeFilter.FILTER_SKIP;
                                }
                            }
                        );

                        let node;
                        while (node = walker.nextNode()) {
                            rubysToDelete.push(node);
                        }

                        rubysToDelete.forEach(ruby => {
                            const prevNode = ruby.previousSibling;
                            const nextNode = ruby.nextSibling;

                            if (prevNode && prevNode.nodeType === 3 && prevNode.textContent === '\u200B') {
                                prevNode.remove();
                            }
                            if (nextNode && nextNode.nodeType === 3 && nextNode.textContent === '\u200B') {
                                nextNode.remove();
                            }

                            ruby.remove();
                        });
                    }

                    range.deleteContents();
                }

                // 新しいruby要素を作成
                const ruby = document.createElement('ruby');
                ruby.textContent = baseText;

                const rt = document.createElement('rt');
                rt.textContent = rubyText;
                ruby.appendChild(rt);

                const before = document.createTextNode('\u200B');
                const after = document.createTextNode('\u200B');

                // 挿入位置が保存されている場合はそこに挿入
                if (insertPosition) {
                    try {
                        const newRange = document.createRange();
                        newRange.setStart(insertPosition.container, insertPosition.offset);
                        newRange.collapse(true);

                        newRange.insertNode(after);
                        newRange.insertNode(ruby);
                        newRange.insertNode(before);

                        newRange.setStart(after, 1);
                        newRange.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(newRange);
                    } catch (e) {
                        // エラーが発生した場合は通常の挿入
                        range.insertNode(after);
                        range.insertNode(ruby);
                        range.insertNode(before);

                        range.setStart(after, 1);
                        range.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                } else {
                    range.insertNode(after);
                    range.insertNode(ruby);
                    range.insertNode(before);

                    range.setStart(after, 1);
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
            }

            savedSelection = null;
        };

        window.updateRuby = function(elementId, baseText, rubyText) {
            const element = document.getElementById(elementId);
            if (!element) return;

            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;

            const range = selection.getRangeAt(0);

            // 選択されているruby要素を取得
            let rubyElement = null;

            if (range.startContainer.nodeType === 1 &&
                range.startContainer.childNodes[range.startOffset]?.nodeName === 'RUBY') {
                rubyElement = range.startContainer.childNodes[range.startOffset];
            } else {
                let node = range.commonAncestorContainer;
                if (node.nodeType === 3) {
                    node = node.parentElement;
                }

                let currentNode = node;
                while (currentNode && currentNode !== element) {
                    if (currentNode.nodeName === 'RUBY') {
                        rubyElement = currentNode;
                        break;
                    }
                    currentNode = currentNode.parentElement;
                }
            }

            if (rubyElement) {
                // 新しいruby要素を作成
                const newRuby = document.createElement('ruby');
                newRuby.textContent = baseText;

                const rt = document.createElement('rt');
                rt.textContent = rubyText;
                newRuby.appendChild(rt);

                // 古いruby要素を置き換え
                rubyElement.parentNode.replaceChild(newRuby, rubyElement);

                // カーソルをルビの後ろに移動
                const afterNode = newRuby.nextSibling;
                if (afterNode && afterNode.nodeType === 3 && afterNode.textContent === '\u200B') {
                    const newRange = document.createRange();
                    newRange.setStart(afterNode, 1);
                    newRange.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                } else {
                    // ゼロ幅スペースがない場合は追加
                    const after = document.createTextNode('\u200B');
                    if (newRuby.nextSibling) {
                        newRuby.parentNode.insertBefore(after, newRuby.nextSibling);
                    } else {
                        newRuby.parentNode.appendChild(after);
                    }

                    const newRange = document.createRange();
                    newRange.setStart(after, 1);
                    newRange.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                }
            }

            savedSelection = null;
        };

        window.checkRubySelection = function(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return null;

            const selection = window.getSelection();
            if (selection.rangeCount === 0) return null;

            const range = selection.getRangeAt(0);

            // ruby要素全体が選択されているかチェック
            if (range.startContainer === range.endContainer &&
                range.startContainer.nodeType === 1) {
                const selectedNode = range.startContainer.childNodes[range.startOffset];
                if (selectedNode && selectedNode.nodeName === 'RUBY') {
                    const baseText = Array.from(selectedNode.childNodes)
                        .filter(n => n.nodeName !== 'RT')
                        .map(n => n.textContent)
                        .join('');
                    const rtElement = selectedNode.querySelector('rt');
                    const rubyText = rtElement ? rtElement.textContent : '';

                    return [baseText, rubyText];
                }
            }

            // 選択範囲の開始・終了位置からruby要素を探す
            let startNode = range.startContainer;
            let endNode = range.endContainer;

            // テキストノードの場合は親要素を取得
            if (startNode.nodeType === 3) {
                startNode = startNode.parentElement;
            }
            if (endNode.nodeType === 3) {
                endNode = endNode.parentElement;
            }

            // 開始位置と終了位置が同じruby要素内にあるかチェック
            let startRuby = null;
            let endRuby = null;

            let node = startNode;
            while (node && node !== element) {
                if (node.nodeName === 'RUBY') {
                    startRuby = node;
                    break;
                }
                node = node.parentElement;
            }

            node = endNode;
            while (node && node !== element) {
                if (node.nodeName === 'RUBY') {
                    endRuby = node;
                    break;
                }
                node = node.parentElement;
            }

            // 同じruby要素内の選択、またはカーソルがruby要素内にある場合
            if (startRuby && startRuby === endRuby) {
                const baseText = Array.from(startRuby.childNodes)
                    .filter(n => n.nodeName !== 'RT')
                    .map(n => n.textContent)
                    .join('');
                const rtElement = startRuby.querySelector('rt');
                const rubyText = rtElement ? rtElement.textContent : '';

                // ruby要素全体を選択し直す
                const newRange = document.createRange();
                newRange.selectNode(startRuby);
                selection.removeAllRanges();
                selection.addRange(newRange);

                return [baseText, rubyText];
            }

            // 複数のruby要素にまたがる選択の場合はnullを返す（新規追加として扱う）
            const fragment = range.cloneContents();
            const tempDiv = document.createElement('div');
            tempDiv.appendChild(fragment);
            const rubysInSelection = tempDiv.querySelectorAll('ruby');

            if (rubysInSelection.length > 0) {
                return null;
            }

            return null;
        };

        // contenteditable要素のクリックイベントを監視
        document.addEventListener('click', function(e) {
            const target = e.target;

            // content-editableまたはcontent-editable-mobile内のクリックか確認
            let editableElement = null;
            if (target.id === 'content-editable' || target.id === 'content-editable-mobile') {
                editableElement = target;
            } else {
                let parent = target.parentElement;
                while (parent) {
                    if (parent.id === 'content-editable' || parent.id === 'content-editable-mobile') {
                        editableElement = parent;
                        break;
                    }
                    parent = parent.parentElement;
                }
            }

            if (!editableElement) return;

            // ruby要素またはその子要素がクリックされた場合の処理
            let rubyElement = null;
            if (target.nodeName === 'RUBY') {
                rubyElement = target;
            } else if (target.nodeName === 'RT') {
                rubyElement = target.parentElement;
            } else if (target.parentElement?.nodeName === 'RUBY') {
                rubyElement = target.parentElement;
            }

            if (rubyElement) {
                // ruby要素全体を選択
                const selection = window.getSelection();
                const range = document.createRange();
                range.selectNode(rubyElement);
                selection.removeAllRanges();
                selection.addRange(range);

                e.preventDefault();
                return;
            }

            // クリック位置が末尾付近で、最後の要素がrubyの場合
            const rect = editableElement.getBoundingClientRect();
            const clickY = e.clientY;

            // 下半分をクリックした場合
            if (clickY > rect.top + rect.height / 2) {
                const lastChild = editableElement.lastChild;
                let needsNewLine = false;

                // 最後の要素がrubyまたはゼロ幅スペースの場合
                if (lastChild) {
                    if (lastChild.nodeName === 'RUBY') {
                        needsNewLine = true;
                    } else if (lastChild.nodeType === 3 && lastChild.textContent === '\u200B' &&
                               lastChild.previousSibling?.nodeName === 'RUBY') {
                        needsNewLine = true;
                    }
                }

                if (needsNewLine) {
                    // 末尾にテキストノードを追加
                    const textNode = document.createTextNode('\u200B');
                    editableElement.appendChild(textNode);

                    const selection = window.getSelection();
                    const range = document.createRange();
                    range.setStart(textNode, 1);
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);

                    editableElement.focus();
                    e.preventDefault();
                }
            }
        });

        // ruby要素内での直接入力を防ぐ
        document.addEventListener('beforeinput', function(e) {
            const target = e.target;

            // content-editableまたはcontent-editable-mobile内の入力か確認
            if (target.id !== 'content-editable' && target.id !== 'content-editable-mobile') {
                return;
            }

            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;

            const range = selection.getRangeAt(0);
            let node = range.startContainer;

            // テキストノードの場合は親要素を取得
            if (node.nodeType === 3) {
                node = node.parentElement;
            }

            // ruby要素内またはrt要素内にいるかチェック
            let currentNode = node;
            let rubyElement = null;

            while (currentNode && currentNode !== target) {
                if (currentNode.nodeName === 'RUBY') {
                    rubyElement = currentNode;
                    break;
                }
                if (currentNode.nodeName === 'RT') {
                    // rt要素内の場合、親のruby要素を取得
                    rubyElement = currentNode.parentElement;
                    break;
                }
                currentNode = currentNode.parentElement;
            }

            // ruby要素内での入力を検出した場合
            if (rubyElement) {
                e.preventDefault();

                // ruby要素の直後にカーソルを移動
                const newRange = document.createRange();
                const afterNode = rubyElement.nextSibling;

                if (afterNode && afterNode.nodeType === 3 && afterNode.textContent === '\u200B') {
                    // 既存のゼロ幅スペースにカーソルを移動
                    newRange.setStart(afterNode, 1);
                } else {
                    // ゼロ幅スペースを追加
                    const zeroWidthSpace = document.createTextNode('\u200B');
                    if (rubyElement.nextSibling) {
                        rubyElement.parentNode.insertBefore(zeroWidthSpace, rubyElement.nextSibling);
                    } else {
                        rubyElement.parentNode.appendChild(zeroWidthSpace);
                    }
                    newRange.setStart(zeroWidthSpace, 1);
                }

                newRange.collapse(true);
                selection.removeAllRanges();
                selection.addRange(newRange);

                // 入力内容が文字の場合は、カーソル位置に挿入
                if (e.data) {
                    document.execCommand('insertText', false, e.data);
                }

                return;
            }
        });

        // inputイベントでもチェック（ペーストや部分削除などの場合）
        document.addEventListener('input', function(e) {
            const target = e.target;

            // content-editableまたはcontent-editable-mobile内の変更か確認
            if (target.id !== 'content-editable' && target.id !== 'content-editable-mobile') {
                return;
            }

            // すべてのruby要素をチェック
            const rubyElements = target.querySelectorAll('ruby');
            const elementsToRemove = [];

            rubyElements.forEach(ruby => {
                // 元のruby構造が壊れているかチェック
                const rtElement = ruby.querySelector('rt');

                // rtがない、または子要素の構造が不正な場合は削除
                if (!rtElement) {
                    elementsToRemove.push(ruby);
                    return;
                }

                // rt要素以外のテキストを取得
                let baseText = '';
                let hasOnlyTextAndRt = true;

                Array.from(ruby.childNodes).forEach(node => {
                    if (node.nodeName === 'RT') {
                        // rtはスキップ
                    } else if (node.nodeType === 3) {
                        // テキストノード
                        baseText += node.textContent;
                    } else {
                        // その他の要素が含まれている場合は構造が壊れている
                        hasOnlyTextAndRt = false;
                    }
                });

                // 構造が壊れているか、ベーステキストが空の場合は削除
                if (!hasOnlyTextAndRt || !baseText || baseText.trim() === '') {
                    elementsToRemove.push(ruby);
                }
            });

            // 削除対象のruby要素を削除
            elementsToRemove.forEach(ruby => {
                // 前後のゼロ幅スペースも削除
                const prevNode = ruby.previousSibling;
                const nextNode = ruby.nextSibling;

                if (prevNode && prevNode.nodeType === 3 && prevNode.textContent === '\u200B') {
                    prevNode.remove();
                }
                if (nextNode && nextNode.nodeType === 3 && nextNode.textContent === '\u200B') {
                    nextNode.remove();
                }

                ruby.remove();
            });
        });

        // キーボード入力でのruby削除処理を追加
        document.addEventListener('keydown', function(e) {
            const target = e.target;

            // content-editableまたはcontent-editable-mobile内の入力か確認
            if (target.id !== 'content-editable' && target.id !== 'content-editable-mobile') {
                return;
            }

            // BackspaceまたはDeleteキーの場合
            if (e.key === 'Backspace' || e.key === 'Delete') {
                const selection = window.getSelection();
                if (selection.rangeCount === 0) return;

                const range = selection.getRangeAt(0);

                // 選択範囲がある場合
                if (!selection.isCollapsed) {
                    const fragment = range.cloneContents();
                    const tempDiv = document.createElement('div');
                    tempDiv.appendChild(fragment);

                    // 選択範囲内または部分的に含まれるruby要素をチェック
                    let affectedRubies = [];

                    // 範囲の開始・終了コンテナからruby要素を探す
                    let startNode = range.startContainer;
                    let endNode = range.endContainer;

                    // 開始位置のruby要素をチェック
                    let node = startNode;
                    while (node && node !== target) {
                        if (node.nodeName === 'RUBY') {
                            affectedRubies.push(node);
                            break;
                        }
                        node = node.parentElement;
                    }

                    // 終了位置のruby要素をチェック（開始と異なる場合）
                    node = endNode;
                    while (node && node !== target) {
                        if (node.nodeName === 'RUBY' && !affectedRubies.includes(node)) {
                            affectedRubies.push(node);
                            break;
                        }
                        node = node.parentElement;
                    }

                    // 範囲内のすべてのruby要素もチェック
                    const rangeRubies = tempDiv.querySelectorAll('ruby');
                    if (rangeRubies.length > 0) {
                        // 実際のDOM内で対応するruby要素を見つける
                        const allRubies = target.querySelectorAll('ruby');
                        allRubies.forEach(ruby => {
                            if (range.intersectsNode(ruby) && !affectedRubies.includes(ruby)) {
                                affectedRubies.push(ruby);
                            }
                        });
                    }

                    if (affectedRubies.length > 0) {
                        e.preventDefault();

                        // 影響を受けるruby要素を全て削除
                        affectedRubies.forEach(ruby => {
                            const prevNode = ruby.previousSibling;
                            const nextNode = ruby.nextSibling;

                            if (prevNode && prevNode.nodeType === 3 && prevNode.textContent === '\u200B') {
                                prevNode.remove();
                            }
                            if (nextNode && nextNode.nodeType === 3 && nextNode.textContent === '\u200B') {
                                nextNode.remove();
                            }

                            ruby.remove();
                        });

                        // 選択範囲内の他のコンテンツも削除
                        if (selection.rangeCount > 0) {
                            const newRange = selection.getRangeAt(0);
                            newRange.deleteContents();
                        }

                        return;
                    }

                    // ruby要素が含まれない通常の削除
                    const hasRuby = tempDiv.querySelector('ruby') !== null;
                    if (hasRuby) {
                        e.preventDefault();
                        range.deleteContents();

                        // 削除後のクリーンアップは後続の処理で行われる
                        setTimeout(() => {
                            const rubyElements = target.querySelectorAll('ruby');
                            rubyElements.forEach(ruby => {
                                const baseText = Array.from(ruby.childNodes)
                                    .filter(n => n.nodeName !== 'RT')
                                    .map(n => n.textContent)
                                    .join('');

                                if (!baseText || baseText.trim() === '') {
                                    const prevNode = ruby.previousSibling;
                                    const nextNode = ruby.nextSibling;

                                    if (prevNode && prevNode.nodeType === 3 && prevNode.textContent === '\u200B') {
                                        prevNode.remove();
                                    }
                                    if (nextNode && nextNode.nodeType === 3 && nextNode.textContent === '\u200B') {
                                        nextNode.remove();
                                    }

                                    ruby.remove();
                                }
                            });
                        }, 0);
                    }
                } else {
                    // カーソル位置のみの場合（選択範囲なし）
                    const node = range.startContainer;
                    let rubyElement = null;

                    // ruby要素の中または隣接しているかチェック
                    if (node.nodeType === 3) {
                        // テキストノードの場合、親がrubyかチェック
                        let parent = node.parentElement;
                        while (parent && parent !== target) {
                            if (parent.nodeName === 'RUBY') {
                                rubyElement = parent;
                                break;
                            }
                            parent = parent.parentElement;
                        }

                        // ruby要素の直前または直後にいるかチェック
                        if (!rubyElement) {
                            if (e.key === 'Backspace') {
                                // Backspaceの場合、直前のノードをチェック
                                if (range.startOffset === 0 && node.previousSibling?.nodeName === 'RUBY') {
                                    rubyElement = node.previousSibling;
                                } else if (node.textContent === '\u200B' && node.previousSibling?.nodeName === 'RUBY') {
                                    rubyElement = node.previousSibling;
                                }
                            } else if (e.key === 'Delete') {
                                // Deleteの場合、直後のノードをチェック
                                if (range.startOffset === node.textContent.length && node.nextSibling?.nodeName === 'RUBY') {
                                    rubyElement = node.nextSibling;
                                } else if (node.textContent === '\u200B' && node.nextSibling?.nodeName === 'RUBY') {
                                    rubyElement = node.nextSibling;
                                }
                            }
                        }
                    } else if (node.nodeType === 1) {
                        // 要素ノードの場合
                        if (e.key === 'Backspace' && range.startOffset > 0) {
                            const prevNode = node.childNodes[range.startOffset - 1];
                            if (prevNode?.nodeName === 'RUBY') {
                                rubyElement = prevNode;
                            }
                        } else if (e.key === 'Delete' && range.startOffset < node.childNodes.length) {
                            const nextNode = node.childNodes[range.startOffset];
                            if (nextNode?.nodeName === 'RUBY') {
                                rubyElement = nextNode;
                            }
                        }
                    }

                    // ruby要素が見つかった場合、全体を削除
                    if (rubyElement) {
                        e.preventDefault();

                        // 前後のゼロ幅スペースも削除
                        const prevNode = rubyElement.previousSibling;
                        const nextNode = rubyElement.nextSibling;

                        if (prevNode && prevNode.nodeType === 3 && prevNode.textContent === '\u200B') {
                            prevNode.remove();
                        }
                        if (nextNode && nextNode.nodeType === 3 && nextNode.textContent === '\u200B') {
                            nextNode.remove();
                        }

                        // カーソル位置を保存
                        const parentNode = rubyElement.parentNode;
                        const nextSibling = rubyElement.nextSibling;

                        rubyElement.remove();

                        // カーソルを削除位置に移動
                        const newRange = document.createRange();
                        if (nextSibling) {
                            newRange.setStartBefore(nextSibling);
                        } else {
                            newRange.selectNodeContents(parentNode);
                            newRange.collapse(false);
                        }
                        selection.removeAllRanges();
                        selection.addRange(newRange);
                    }
                }
            }
        });

        window.saveSelectionForRuby = function(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return;

            const selection = window.getSelection();

            // 選択範囲が存在し、かつeditable要素内にあるかチェック
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                let node = range.commonAncestorContainer;

                // editable要素内にあるかチェック
                let isInside = false;
                let checkNode = node;
                while (checkNode) {
                    if (checkNode === element) {
                        isInside = true;
                        break;
                    }
                    checkNode = checkNode.parentNode;
                }

                if (isInside) {
                    // 要素内にある場合は現在の位置を保存
                    savedSelection = {
                        range: range.cloneRange(),
                        elementId: elementId
                    };
                    return;
                }
            }

            // 要素内にない場合、または選択範囲がない場合は末尾に移動
            element.focus();
            const newRange = document.createRange();

            // 要素の末尾にカーソルを配置
            if (element.childNodes.length > 0) {
                const lastChild = element.lastChild;

                // 最後の子要素がテキストノードの場合
                if (lastChild.nodeType === 3) {
                    newRange.setStart(lastChild, lastChild.textContent.length);
                } else {
                    // それ以外の場合は要素の末尾
                    newRange.selectNodeContents(element);
                    newRange.collapse(false);
                }
            } else {
                // 子要素がない場合は要素自体の末尾
                newRange.selectNodeContents(element);
                newRange.collapse(false);
            }

            newRange.collapse(true);

            savedSelection = {
                range: newRange,
                elementId: elementId
            };

            selection.removeAllRanges();
            selection.addRange(newRange);
        };

        window.undoEditor = function(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return;

            element.focus();
            document.execCommand('undo');
        };

        window.redoEditor = function(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return;

            element.focus();
            document.execCommand('redo');
        };

        window.clearFormat = function(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return;

            element.focus();
            const selection = window.getSelection();

            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);

                if (!selection.isCollapsed) {
                    // 選択範囲がある場合：選択部分の書式をクリア
                    const selectedContent = range.extractContents();
                    const textContent = selectedContent.textContent;
                    const textNode = document.createTextNode(textContent);

                    range.insertNode(textNode);
                    range.collapse(false);
                    selection.removeAllRanges();
                    selection.addRange(range);
                } else {
                    // 選択範囲がない場合：現在の行全体の書式をクリア
                    const currentNode = range.startContainer;
                    let blockElement = currentNode.nodeType === 3 ? currentNode.parentElement : currentNode;

                    // ブロック要素を見つける
                    while (blockElement && blockElement !== element && !isBlockElement(blockElement)) {
                        blockElement = blockElement.parentElement;
                    }

                    if (blockElement && blockElement !== element) {
                        // カーソル位置を保存
                        const offset = getCaretOffset(blockElement, range);

                        // テキストのみを抽出
                        const textContent = blockElement.textContent;

                        // 新しいp要素（通常の段落）を作成
                        const newElement = document.createElement('p');
                        newElement.textContent = textContent;
                        blockElement.parentNode.replaceChild(newElement, blockElement);

                        // カーソル位置を復元
                        restoreCaretOffset(newElement, offset);
                    }
                }
            }

            // 書式状態をリセット
            currentFormat.bold = false;
            currentFormat.italic = false;
            currentFormat.underline = false;
            notifyFormatStates();
        };
    })();

    window.getActiveEditorContent = function () {
        if (window.mobileEditor) {
            return window.mobileEditor.getContent();
        }
        if (window.pcEditor) {
            return window.pcEditor.getContent();
        }
        return "";
    };
</script>