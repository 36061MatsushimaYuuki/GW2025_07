@page "/projects/edit/{id:int}"

@rendermode InteractiveServer
@attribute [Authorize]

@using Microsoft.AspNetCore.Identity
@using Microsoft.AspNetCore.Authorization
@using Microsoft.EntityFrameworkCore
@using StoryDesignSupportWebApp.Data
@using StoryDesignSupportWebApp.Data.EditData
@using System.Text.Json
@using Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage
@inject UserManager<ApplicationUser> UserManager
@inject IDbContextFactory<ApplicationDbContext> DbFactory
@inject NavigationManager Nav
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject IJSRuntime JSRuntime
@inject ProtectedSessionStorage SessionStorage

<PageTitle>Project Edit</PageTitle>

<style>
    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }

    body {
        overflow: hidden;
    }

    .edit-container {
        display: flex;
        height: calc(100vh - 5.5rem);
        overflow: hidden;
        max-width: 100vw;
        transition: height 0.3s ease;
    }

    /* サイドバー（PC用） */
    .sidebar {
        width: 300px;
        background-color: #fafbfc;
        border-right: 1px solid #e1e4e8;
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        position: relative;
        transition: margin-left 0.3s ease;
        box-shadow: 2px 0 8px rgba(0, 0, 0, 0.04);
    }

        .sidebar.collapsed {
            margin-left: -300px;
            width: 300px;
        }

    .sidebar-header {
        padding: 15px;
        border-bottom: 1px solid #e1e4e8;
        background-color: #0066cc;
        cursor: pointer;
        color: white;
        font-weight: 600;
        transition: all 0.2s ease;
    }

        .sidebar-header:hover {
            background-color: #0550ae;
        }

    /* サイドバー開閉ボタン */
    .sidebar-toggle {
        position: absolute;
        bottom: 15px;
        right: 15px;
        background-color: #0969da;
        color: white;
        border: none;
        border-radius: 8px;
        width: 36px;
        height: 36px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        z-index: 10;
        box-shadow: 0 3px 10px rgba(9, 105, 218, 0.25);
        transition: all 0.2s ease;
    }

        .sidebar-toggle:hover {
            background-color: #0550ae;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(9, 105, 218, 0.35);
        }

    .sidebar-open-btn {
        position: fixed;
        left: 0;
        top: 50%;
        transform: translateY(-50%);
        background-color: #0969da;
        color: white;
        border: none;
        border-radius: 0 8px 8px 0;
        width: 36px;
        height: 56px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        z-index: 10;
        box-shadow: 3px 0 10px rgba(9, 105, 218, 0.25);
        transition: all 0.2s ease;
    }

        .sidebar-open-btn:hover {
            background-color: #0550ae;
            transform: translateY(-50%);
            box-shadow: 3px 0 15px rgba(9, 105, 218, 0.35);
        }

    .category-view, .chapter-view {
        flex: 1;
        overflow-y: auto;
    }

    .category-item {
        padding: 16px 20px;
        border-bottom: 1px solid #e1e4e8;
        cursor: pointer;
        transition: all 0.2s ease;
        font-weight: 500;
        border-left: 3px solid transparent;
    }

        .category-item:hover {
            background-color: #f6f8fa;
            border-left-color: #0969da;
        }

        .category-item.active {
            background-color: #ddf4ff;
            color: #0969da;
            border-left-color: #0969da;
            font-weight: 600;
        }

    .chapter-item {
        border-left: 1px solid #e1e4e8;
        border-bottom: 1px solid #e0e0e0;
    }

    .chapter-header {
        padding: 14px 20px 14px 15px;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background-color: #ffffff;
        transition: all 0.2s ease;
        border-left: 3px solid transparent;
    }

        .chapter-header:hover {
            background-color: #f6f8fa;
            border-left-color: #0969da;
        }

    .chapter-title {
        flex: 1;
        font-size: 18px;
        font-weight: 600;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        color: #24292f;
    }

    .toggle-icon {
        margin-left: -2px;
        margin-right: 12px;
        font-size: 12px;
        display: inline-block;
        width: 12px;
        text-align: center;
        transition: transform 0.3s ease;
    }

        .toggle-icon.expanded {
            transform: rotate(90deg);
        }

    .add-section-btn {
        background: none;
        border: none;
        color: #0066cc;
        cursor: pointer;
        font-size: 18px;
        padding: 0 8px;
    }

        .add-section-btn:hover {
            color: #0052a3;
        }

    .sections-list {
        background-color: #f6f8fa;
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.4s ease;
    }

        .sections-list.expanded {
            max-height: 2000px;
        }

    .section-item {
        padding: 12px 20px 12px 35.5px;
        cursor: pointer;
        border-top: 1px solid #e1e4e8;
        position: relative;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        transition: all 0.2s ease;
        font-size: 15px;
        border-left: 3px solid transparent;
    }

        .section-item::before {
            content: "・";
            position: absolute;
            left: 11px;
            color: #656d76;
        }

        .section-item:hover {
            background-color: #ffffff;
            border-left: 3px solid #0969da;
        }

        .section-item.active {
            background-color: #ddf4ff;
            color: #0969da;
            font-weight: 600;
            border-left: 3px solid #0969da;
        }

        .section-item.dragging {
            opacity: 0.6;
            background-color: #f6f8fa;
        }

        .section-item.drag-over-top {
            border-top: 3px solid #0969da;
            background-color: #ddf4ff;
        }

        .section-item.drag-over-bottom {
            border-bottom: 3px solid #0969da;
            background-color: #ddf4ff;
        }

    .add-chapter-btn {
        margin: 15px;
        padding: 10px;
        background-color: #0969da;
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
        transition: all 0.2s ease;
        box-shadow: 0 2px 8px rgba(9, 105, 218, 0.2);
    }

        .add-chapter-btn:hover {
            background-color: #0550ae;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(9, 105, 218, 0.3);
        }

    .empty-message {
        padding: 20px;
        text-align: center;
        color: #999;
    }

    /* 編集エリア */
    .editor-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        min-width: 0;
        transition: margin-left 0.3s ease;
    }

        .editor-area.expanded {
            margin-left: 0;
        }

    .editor-header {
        padding: 15px 20px;
        border-bottom: 1px solid #ddd;
        background-color: #fff;
        overflow: hidden;
    }

    .editor-title {
        font-size: 20px;
        font-weight: bold;
        margin-bottom: 10px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        max-width: 100%;
    }

    .section-title-input {
        width: 100%;
        padding: 8px;
        font-size: 16px;
        border: none;
        border-bottom: 2px solid #e1e4e8;
        background: transparent;
        outline: none;
        box-sizing: border-box;
    }

        .section-title-input:focus {
            border-bottom-color: #0969da;
        }

    .editor-toolbar {
        padding: 10px;
        background-color: #f9f9f9;
        border-bottom: 1px solid #ddd;
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
        align-items: center;
    }

    .toolbar-btn {
        padding: 6px 12px;
        background-color: #fff;
        border: 1px solid #ccc;
        border-radius: 3px;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.2s;
        white-space: nowrap;
        min-width: 36px;
        width: max-content;
        min-height: 36px;
        max-height: 36px;
    }

        .toolbar-btn.undo {
            line-height: calc(36px / 2 + 4px);
        }

        .toolbar-btn.redo {
            line-height: calc(36px / 2 + 4px);
        }

        .toolbar-btn.move {
            transform: rotate(90deg);
        }

        .toolbar-btn:hover {
            background-color: #e8e8e8;
        }

        .toolbar-btn.active {
            background-color: #0066cc;
            color: white;
            border-color: #0066cc;
        }

        .toolbar-btn:disabled {
            background-color: #e0e0e0;
            color: #999;
            cursor: not-allowed;
            border-color: #ccc;
        }

            .toolbar-btn:disabled:hover {
                background-color: #e0e0e0;
            }

    .toolbar-separator {
        width: 1px;
        height: 20px;
        background-color: #ccc;
        margin: 0 3px;
    }

    .color-picker-container {
        position: relative;
        display: inline-block;
    }

    .color-indicator-btn {
        padding: 7px;
        background-color: #fff;
        border: 1px solid #ccc;
        border-radius: 3px;
        cursor: pointer;
        transition: background-color 0.2s;
        width: 36px;
        height: 36px;
        position: relative;
    }

        .color-indicator-btn:hover {
            background-color: #e8e8e8;
        }

        .color-indicator-btn .color-box {
            width: 20px;
            height: 20px;
            border: 1px solid #999;
            border-radius: 2px;
            display: inline-block;
        }

    .color-picker-dropdown {
        position: fixed;
        background: white;
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 10px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        z-index: 1000;
        display: none;
        min-width: 200px;
    }

        .color-picker-dropdown.show {
            display: block;
        }

    .color-picker-input-wrapper {
        display: flex;
        gap: 5px;
        margin-bottom: 8px;
    }

    .native-color-picker {
        width: 50px;
        height: 35px;
        border: 1px solid #ddd;
        border-radius: 3px;
        cursor: pointer;
    }

    .color-input {
        flex: 1;
        padding: 5px 8px;
        border: 1px solid #ddd;
        border-radius: 3px;
        font-size: 14px;
    }

    .color-apply-btn {
        padding: 5px 12px;
        background: #0066cc;
        color: white;
        border: none;
        border-radius: 3px;
        cursor: pointer;
        font-size: 14px;
    }

        .color-apply-btn:hover {
            background: #0052a3;
        }

    .color-remove-btn {
        width: 100%;
        padding: 5px;
        background: #f5f5f5;
        border: 1px solid #ddd;
        border-radius: 3px;
        cursor: pointer;
        font-size: 12px;
    }

        .color-remove-btn:hover {
            background: #e8e8e8;
        }

    .recent-colors {
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid #eee;
    }

    .recent-colors-title {
        font-size: 11px;
        color: #666;
        margin-bottom: 5px;
    }

    .recent-colors-list {
        display: flex;
        gap: 5px;
        flex-wrap: wrap;
    }

    .recent-color-option {
        width: 25px;
        height: 25px;
        border: 2px solid #ddd;
        border-radius: 3px;
        cursor: pointer;
        transition: transform 0.1s;
    }

        .recent-color-option:hover {
            transform: scale(1.1);
            border-color: #999;
        }

    .editor-content {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
    }

    .content-editable {
        min-height: 400px;
        padding: 15px;
        border: none;
        border-radius: 4px;
        font-size: 16px;
        font-family: inherit;
        line-height: 1.6;
        outline: none;
        background-color: white;
        word-wrap: break-word;
        overflow-wrap: break-word;
    }

        .content-editable:focus {
            border-color: none;
        }

        /* 各要素の行間を明示的に指定 */
        .content-editable p {
            line-height: 1.6;
            margin: 0;
        }

        .content-editable h1 {
            line-height: 1.3;
            margin: 0;
        }

        .content-editable h2 {
            line-height: 1.3;
            margin: 0;
        }

        .content-editable h3 {
            line-height: 1.3;
            margin: 0;
        }

        .content-editable b,
        .content-editable strong,
        .content-editable i,
        .content-editable em,
        .content-editable u {
            line-height: inherit;
        }

        .content-editable ruby {
            line-height: inherit;
            cursor: text;
        }

        .content-editable rt {
            font-size: 0.5em;
        }

    /* モバイルビュー */
    .mobile-view {
        display: none;
        height: calc(100vh - 5.5rem);
        overflow: hidden;
        transition: height 0.3s ease;
    }

    .mobile-list {
        display: flex;
        flex-direction: column;
        position: relative;
        height: calc(100vh - 5.5rem);
        overflow-y: auto;
        background-color: #f5f5f5;
        transition: height 0.3s ease;
    }

    .mobile-chapter-view {
        flex: 1;
        overflow-y: auto;
    }

    .mobile-header {
        padding: 15px;
        background-color: #0066cc;
        color: white;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .mobile-editor {
        height: calc(100vh - 5.5rem);
        display: flex;
        flex-direction: column;
        background-color: #fff;
        transition: height 0.3s ease;
    }

    .mobile-editor-header {
        padding: 15px;
        background-color: #0066cc;
        color: white;
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .back-btn {
        background: none;
        border: none;
        color: white;
        font-size: 18px;
        cursor: pointer;
        padding: 0;
    }

    .mobile-editor-title {
        flex: 1;
        font-size: 18px;
        font-weight: bold;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    /* モーダル */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        animation: fadeIn 0.2s ease;
    }

    @@keyframes fadeIn {
        from {
            opacity: 0;
        }

        to {
            opacity: 1;
        }
    }

    .modal-content {
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        min-width: 300px;
        max-width: 450px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        animation: slideUp 0.3s ease;
    }

    @@keyframes slideUp {
        from {
            transform: translateY(20px);
            opacity: 0;
        }

        to {
            transform: translateY(0);
            opacity: 1;
        }
    }

    .modal-header {
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 15px;
    }

    .modal-body {
        margin-bottom: 20px;
    }

    .modal-input {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
    }

        .modal-input:read-only {
            background-color: #f0f0f0;
            color: #999;
            cursor: not-allowed;
        }

    .modal-buttons {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
    }

    .modal-btn {
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }

    .modal-btn-primary {
        background-color: #0066cc;
        color: white;
    }

        .modal-btn-primary:hover {
            background-color: #0052a3;
        }

    .modal-btn-danger {
        background-color: #dc3545;
        color: white;
    }

        .modal-btn-danger:hover {
            background-color: #c82333;
        }

    .modal-btn-secondary {
        background-color: #6c757d;
        color: white;
    }

        .modal-btn-secondary:hover {
            background-color: #5a6268;
        }

    .settings-btn {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 16px;
        padding: 0 8px;
        margin-left: 4px;
        margin-right: -10px;
        color: #666;
    }

        .settings-btn:hover {
            color: #333;
        }

    .desktop-btn {
        opacity: 0;
        transition: opacity 0.2s ease;
    }

    .chapter-header:hover .desktop-btn {
        opacity: 1;
    }

    .section-item:hover .desktop-btn {
        opacity: 1;
    }

    .delete-section-btn {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 16px;
        padding: 0 8px;
        margin-left: 4px;
        margin-right: -8px;
        color: #ff2222;
        font-weight: bold;
    }

    .delete-section:hover {
        color: #ff1111;
    }

    .modal-section {
        margin-bottom: 15px;
    }

        .modal-section:last-child {
            margin-bottom: 0;
        }

    .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: #8c959f;
        font-size: 16px;
    }

    /* レスポンシブ */
    @@media (max-width: 768px) {
        .desktop-view {
            display: none !important;
        }

        .mobile-view {
            display: block;
            width: 100%;
        }

        .chapter-item {
            border-right: 1px solid #e1e4e8;
        }

        .editor-toolbar {
            padding: 8px;
            gap: 3px;
            overflow: hidden;
            max-width: 100vw;
            max-height: 52px;
            transition: max-height 0.3s ease;
        }

            .editor-toolbar.moved {
                max-height: 98px;
            }

        .toolbar-btn {
            padding: 8px 10px;
            font-size: 12px;
            margin-bottom: 7px;
        }

            .toolbar-btn.undo {
                line-height: calc(36px / 2 + 2px);
            }

            .toolbar-btn.redo {
                line-height: calc(36px / 2 + 2px);
            }

        .color-indicator-btn {
            margin-top: -6px;
        }

        .content-editable {
            min-height: 300px;
        }

        .sidebar-toggle,
        .sidebar-open-btn {
            display: none;
        }

        .sidebar.collapsed {
            margin-left: 0;
            width: 300px;
        }

        .color-picker-dropdown {
            min-width: 280px;
            max-width: calc(100vw - 20px);
        }
    }

    .mobile-category-ui {
        position: sticky;
        display: flex;
        align-items: center;
        justify-content: center;
        bottom: 0;
        width: max-content;
        margin: 0 auto;
    }

    .category-select-button {
        width: 64px;
        height: 64px;
        cursor: pointer;
        line-height: 64px;
        text-align: center;
        align-items: center;
        justify-content: center;
        background-color: lightgrey;
        border: solid;
        border-color: grey;
    }

        .category-select-button + .category-select-button {
            border-left: none;
        }

        .category-select-button:first-child {
            border-top-left-radius: 10%;
            border-bottom-left-radius: 10%;
        }

        .category-select-button:last-child {
            border-top-right-radius: 10%;
            border-bottom-right-radius: 10%;
        }

        .category-select-button:hover {
            background-color: grey;
        }

        .category-select-button.active {
            background-color: #0066cc;
            color: white;
        }

            .category-select-button.active:hover {
                background-color: #0052a3;
            }

    #char-counter {
        position: fixed;
        right: 16px;
        bottom: 16px;
        font-size: 14px;
        color: #666;
        background: rgba(255, 255, 255, 0.9);
        padding: 6px 10px;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0,0,0,0.15);
        pointer-events: none;
        z-index: 999;
    }

    #char-counter-mobile {
        position: fixed;
        right: 16px;
        bottom: 16px;
        font-size: 14px;
        color: #666;
        background: rgba(255, 255, 255, 0.9);
        padding: 6px 10px;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0,0,0,0.15);
        pointer-events: none;
        z-index: 999;
    }

    .hidden {
        display: none;
    }
</style>

@if (_project == null) {
    <p>Loading...</p>
} else {
    <!-- 章追加モーダル -->
    @if (_showAddChapterModal) {
        <div class="modal-overlay" @onclick="CloseAddChapterModal">
            <div class="modal-content" @onclick:stopPropagation="true">
                <div class="modal-header">新しい章を追加</div>
                <div class="modal-body">
                    <input type="text" class="modal-input" @bind="_newChapterTitle" placeholder="章のタイトルを入力" maxlength="90" @onkeydown="HandleAddChapterModalKeyDown" />
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn modal-btn-secondary" @onclick="CloseAddChapterModal">キャンセル</button>
                    <button class="modal-btn modal-btn-primary" @onclick="ConfirmAddChapter">追加</button>
                </div>
            </div>
        </div>
    }

    <!-- 話追加モーダル -->
    @if (_showAddSectionModal) {
        <div class="modal-overlay" @onclick="CloseAddSectionModal">
            <div class="modal-content" @onclick:stopPropagation="true">
                <div class="modal-header">新しい話を追加</div>
                <div class="modal-body">
                    <input type="text" class="modal-input" @bind="_newSectionTitle" placeholder="話のタイトルを入力" maxlength="90" @onkeydown="HandleAddSectionModalKeyDown" />
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn modal-btn-secondary" @onclick="CloseAddSectionModal">キャンセル</button>
                    <button class="modal-btn modal-btn-primary" @onclick="ConfirmAddSection">追加</button>
                </div>
            </div>
        </div>
    }

    <!-- 章設定モーダル -->
    @if (_showChapterSettingsModal) {
        <div class="modal-overlay" @onclick="CloseChapterSettings">
            <div class="modal-content" @onclick:stopPropagation="true">
                <div class="modal-header">章の設定</div>
                <div class="modal-body">
                    <div class="modal-section">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">章のタイトル</label>
                        <input type="text" class="modal-input" @bind="_editingChapterTitle" maxlength="90" @onkeydown="HandleChapterSettingsKeyDown" />
                    </div>
                    <div class="modal-section">
                        <button class="modal-btn modal-btn-danger" style="width: 100%;" @onclick="ShowDeleteChapterConfirm">章を削除</button>
                    </div>
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn modal-btn-secondary" @onclick="CloseChapterSettings">キャンセル</button>
                    <button class="modal-btn modal-btn-primary" @onclick="SaveChapterSettings">保存</button>
                </div>
            </div>
        </div>
    }

    <!-- 章削除確認モーダル -->
    @if (_showDeleteChapterConfirm) {
        <div class="modal-overlay" @onclick="CloseDeleteChapterConfirm">
            <div class="modal-content" @onclick:stopPropagation="true">
                <div class="modal-header">章の削除</div>
                <div class="modal-body">
                    <p>この章を削除してもよろしいですか？</p>
                    <p style="color: #dc3545; margin-top: 10px;">※この章に含まれるすべての話も削除されます。</p>
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn modal-btn-secondary" @onclick="CloseDeleteChapterConfirm">キャンセル</button>
                    <button class="modal-btn modal-btn-danger" @onclick="ConfirmDeleteChapter">削除</button>
                </div>
            </div>
        </div>
    }

    <!-- 話削除確認モーダル -->
    @if (_showDeleteSectionConfirm) {
        <div class="modal-overlay" @onclick="CloseDeleteSectionConfirm">
            <div class="modal-content" @onclick:stopPropagation="true">
                <div class="modal-header">話の削除</div>
                <div class="modal-body">
                    <p>この話を削除してもよろしいですか？</p>
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn modal-btn-secondary" @onclick="CloseDeleteSectionConfirm">キャンセル</button>
                    <button class="modal-btn modal-btn-danger" @onclick="ConfirmDeleteSection">削除</button>
                </div>
            </div>
        </div>
    }

    <!-- ルビ追加モーダル -->
    @if (_showRubyModal) {
        <div class="modal-overlay" @onclick="CloseRubyModal">
            <div class="modal-content" @onclick:stopPropagation="true">
                <div class="modal-header">@(_isEditingRuby ? "ルビを編集" : "ルビを追加")</div>
                <div class="modal-body">
                    <div class="modal-section">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">テキスト</label>
                        <input type="text"
                               class="modal-input"
                               @bind="_rubyBase"
                               placeholder="漢字など"
                               readonly="@(_hasSelectedText || _isEditingRuby)" />
                    </div>
                    <div class="modal-section">
                        <label style="display: block; margin-bottom: 5px; font-weight: bold;">ルビ</label>
                        <input type="text" class="modal-input" @bind="_rubyText" placeholder="ふりがな" @onkeydown="HandleRubyModalKeyDown" />
                    </div>
                    @if (_isEditingRuby) {
                        <div class="modal-section">
                            <button class="modal-btn modal-btn-danger" style="width: 100%;" @onclick="ConfirmDeleteRuby">ルビを削除</button>
                        </div>
                    }
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn modal-btn-secondary" @onclick="CloseRubyModal">キャンセル</button>
                    <button class="modal-btn modal-btn-primary" @onclick="ConfirmAddRuby">@(_isEditingRuby ? "更新" : "追加")</button>
                </div>
            </div>
        </div>
    }
    <!-- デスクトップビュー -->
    <div class="edit-container desktop-view">
        <!-- サイドバー開くボタン（サイドバーが閉じているときのみ表示） -->
        @if (_sidebarCollapsed) {
            <button class="sidebar-open-btn" @onclick="ToggleSidebar">▶</button>
        }

        <!-- サイドバー -->
        <div class="sidebar @(_sidebarCollapsed ? "collapsed" : "")">
            @if (_showCategoryView) {
                <div class="sidebar-header" @onclick="BackToCategoryView">
                    &lt; カテゴリ選択に戻る
                </div>
                <div class="chapter-view">
                    @if (_project.ProjectDataObject?.Scenario?.Chapters == null || _project.ProjectDataObject.Scenario.Chapters.Length == 0) {
                        <div class="empty-message">章がありません</div>
                    } else {
                        @for (int i = 0; i < _project.ProjectDataObject.Scenario.Chapters.Length; i++) {
                            var chapterIndex = i;
                            var chapter = _project.ProjectDataObject.Scenario.Chapters[i];
                            <div class="chapter-item" @key="@($"chapter-{chapterIndex}")">
                                <div class="chapter-header">
                                    <span class="toggle-icon @(_expandedChapters.Contains(chapterIndex) ? "expanded" : "")" @onclick="() => ToggleChapter(chapterIndex)">
                                        ▶
                                    </span>
                                    <span class="chapter-title" @onclick="() => ToggleChapter(chapterIndex)">
                                        @(string.IsNullOrEmpty(chapter.Title) ? $"Chapter {chapterIndex + 1}" : chapter.Title)
                                    </span>
                                    <div class="desktop-btn">
                                        <button class="add-section-btn" @onclick="() => ShowAddSectionModal(chapterIndex)">+</button>
                                        <button class="settings-btn" @onclick="() => ShowChapterSettings(chapterIndex)">⚙</button>
                                    </div>
                                </div>
                                <div class="sections-list @(_expandedChapters.Contains(chapterIndex) ? "expanded" : "")">
                                    @if (chapter.Sections == null || chapter.Sections.Length == 0) {
                                        <div class="empty-message" style="padding: 10px 40px;">話がありません</div>
                                    } else {
                                        @for (int j = 0; j < chapter.Sections.Length; j++) {
                                            var sectionIndex = j;
                                            var section = chapter.Sections[j];
                                            <div class="section-item @(_selectedChapter == chapterIndex && _selectedSection == sectionIndex ? "active" : "") @(GetDragClass(chapterIndex, sectionIndex))"
                                                 @key="@($"section-{chapterIndex}-{sectionIndex}")"
                                                 draggable="true"
                                                 @ondragstart="() => HandleDragStart(chapterIndex, sectionIndex)"
                                                 @ondragend="HandleDragEnd"
                                                 @ondragover="(e) => HandleDragOver(e, chapterIndex, sectionIndex)"
                                                 @ondragleave="HandleDragLeave"
                                                 @ondragover:preventDefault="true"
                                                 @ondrop="() => HandleDrop(chapterIndex, sectionIndex)"
                                                 style="display: flex; justify-content: space-between; align-items: center;">
                                                <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; padding-right: 5px;" @onclick="() => SelectSection(chapterIndex, sectionIndex)">
                                                    @(string.IsNullOrEmpty(section.Title) ? $"Section {sectionIndex + 1}" : section.Title)
                                                </span>
                                                <div class="desktop-btn">
                                                    <button class="delete-section-btn" style="font-size: 14px; flex-shrink: 0;" @onclick="() => ShowDeleteSectionConfirm(chapterIndex, sectionIndex)">−</button>
                                                </div>
                                            </div>
                                        }
                                    }
                                </div>
                            </div>
                        }
                    }
                    <button class="add-chapter-btn" @onclick="ShowAddChapterModal">+ 章を追加</button>
                </div>
            } else {
                <div class="sidebar-header" @onclick="BackToProjectList">
                    &lt; 一覧に戻る
                </div>
                <div class="category-view">
                    <div class="category-item @(_currentCategory == "writing" ? "active" : "")" @onclick='() => SelectCategory("writing")'>
                        執筆
                    </div>
                    <div class="category-item" @onclick='() => SelectCategory("structure")'>
                        構成
                    </div>
                    <div class="category-item" @onclick='() => SelectCategory("materials")'>
                        資料
                    </div>
                </div>
            }

            <!-- サイドバー閉じるボタン（サイドバーが開いているときのみ表示） -->
            @if (!_sidebarCollapsed) {
                <button class="sidebar-toggle" @onclick="ToggleSidebar">◀</button>
            }
        </div>

        <!-- 編集エリア -->
        <div class="editor-area">
            @if (_selectedChapter >= 0 && _selectedSection >= 0 &&
                    _project.ProjectDataObject?.Scenario?.Chapters != null &&
                    _selectedChapter < _project.ProjectDataObject.Scenario.Chapters.Length &&
                    _project.ProjectDataObject.Scenario.Chapters[_selectedChapter].Sections != null &&
                    _selectedSection < _project.ProjectDataObject.Scenario.Chapters[_selectedChapter].Sections.Length) {

                var section = _project.ProjectDataObject.Scenario.Chapters[_selectedChapter].Sections[_selectedSection];

                <div class="editor-header">
                    <div class="editor-title">
                        @(
                                        string.IsNullOrEmpty(
                                        _project.ProjectDataObject.Scenario.Chapters[_selectedChapter].Title
                                        )
                                        ? $"Chapter {_selectedChapter + 1}"
                                        : _project.ProjectDataObject.Scenario.Chapters[_selectedChapter].Title
                                        )
                </div>
                <input type="text" class="section-title-input" @bind="section.Title" @bind:event="oninput" @bind:after="AutoSave" placeholder="セクションタイトル" maxlength="90" />
            </div>

                <div class="editor-toolbar">
                    <button class="toolbar-btn undo" @onclick="Undo" title="Undo" disabled="@(!_canUndo)">⬅</button>
                    <button class="toolbar-btn redo" @onclick="Redo" title="Redo" disabled="@(!_canRedo)">⮕</button>
                    <div class="toolbar-separator"></div>
                    <button class="toolbar-btn @(_formatStates["bold"] ? "active" : "")" @onclick='() => ToggleFormat("bold")' title="太字" disabled="@_isFormatButtonDisabled"><b>B</b></button>
                    <button class="toolbar-btn @(_formatStates["italic"] ? "active" : "")" @onclick='() => ToggleFormat("italic")' title="斜体" disabled="@_isFormatButtonDisabled"><i>I</i></button>
                    <button class="toolbar-btn @(_formatStates["underline"] ? "active" : "")" @onclick='() => ToggleFormat("underline")' title="下線" disabled="@_isFormatButtonDisabled"><u>U</u></button>
                    <div class="toolbar-separator"></div>
                    <button class="toolbar-btn" @onclick='() => ApplyFormat("p")'>本文</button>
                    <button class="toolbar-btn" @onclick='() => ApplyFormat("h1")'>H1</button>
                    <button class="toolbar-btn" @onclick='() => ApplyFormat("h2")'>H2</button>
                    <button class="toolbar-btn" @onclick='() => ApplyFormat("h3")'>H3</button>
                    <div class="toolbar-separator"></div>
                    <div class="color-picker-container">
                        <button class="color-indicator-btn" @onclick="ToggleColorPicker">
                            <span class="color-box" style="background-color: @_currentTextColor;"></span>
                        </button>
                        <div class="color-picker-dropdown @(_showColorPicker ? "show" : "")" @onclick:stopPropagation="true">
                            <div class="color-picker-input-wrapper">
                                <input type="color" class="native-color-picker" @bind="_selectedColor" @bind:event="oninput" />
                                <input type="text" class="color-input" @bind="_selectedColor" @bind:event="oninput" placeholder="#000000" maxlength="7" />
                                <button class="color-apply-btn" @onclick="ApplySelectedColor">適用</button>
                            </div>
                            <button class="color-remove-btn" @onclick="RemoveColor">× カラーを戻す</button>

                    @if (_recentColors.Count > 0) {
                                <div class="recent-colors">
                                    <div class="recent-colors-title">最近使った色</div>
                                    <div class="recent-colors-list">
                                        @foreach (var color in _recentColors) {
                                            <div class="recent-color-option"
                                                 style="background-color: @color;"
                                                 @onclick="() => ApplyRecentColor(color)"
                                                 title="@color"></div>
                                        }
                                    </div>
                                </div>
                            }
                        </div>
                    </div>
                    <div class="toolbar-separator"></div>
                    <button class="toolbar-btn" @onclick="ShowRubyModal" title="ルビ" disabled="@_isRubyButtonDisabled">ルビ</button>
                    <div class="toolbar-separator"></div>
                    <button class="toolbar-btn" @onclick="InsertQuotes" title="かぎかっこ">｢｣</button>
                    <button class="toolbar-btn" @onclick='() => InsertText("…")' title="三点リーダー">…</button>
                    <button class="toolbar-btn" @onclick='() => InsertText(" ")' title="半角スペース" style="font-weight: bold">␣</button>
                    <button class="toolbar-btn" @onclick='() => InsertText("—")' title="ダッシュ">―</button>
                    <div class="toolbar-separator"></div>
                    <button class="toolbar-btn" @onclick="ClearFormat" title="書式をクリア">✕ クリア</button>
                </div>

                <div class="editor-content">
                    <div @key="@($"{_selectedChapter}-{_selectedSection}")"
                         id="content-editable"
                         class="content-editable"
                         contenteditable="true"
                         @oninput="OnContentInput"
                         @onkeydown="OnKeyDown">
                    </div>
                </div>
                <div id="char-counter">0文字</div>
            } else {
                <div class="editor-content">
                    @if (_showCategoryView) {
                        <div class="empty-state">
                            編集する話を選択してください
                        </div>
                    } else {
                        <div class="empty-state">
                            左のサイドバーからカテゴリーを選択してください
                        </div>
                    }
                </div>
            }
        </div>
    </div>

    <!-- モバイルビュー -->
    <div class="mobile-view">
        @if (_mobileShowEditor) {
            @if (_selectedChapter >= 0 && _selectedSection >= 0 &&
                _project.ProjectDataObject?.Scenario?.Chapters != null &&
                _selectedChapter < _project.ProjectDataObject.Scenario.Chapters.Length &&
                _project.ProjectDataObject.Scenario.Chapters[_selectedChapter].Sections != null &&
                _selectedSection < _project.ProjectDataObject.Scenario.Chapters[_selectedChapter].Sections.Length) {

                var section = _project.ProjectDataObject.Scenario.Chapters[_selectedChapter].Sections[_selectedSection];

                <div class="mobile-editor">
                    <div class="mobile-editor-header">
                        <button class="back-btn" @onclick="BackToList">&lt;</button>
                        <div class="mobile-editor-title">
                            @(
                                            string.IsNullOrEmpty(
                                            _project.ProjectDataObject.Scenario.Chapters[_selectedChapter].Title
                                            )
                                            ? $"Chapter {_selectedChapter + 1}"
                                            : _project.ProjectDataObject.Scenario.Chapters[_selectedChapter].Title
                                            )
                    </div>
                </div>

                    <div style="padding: 10px; border-bottom: 1px solid #ddd;">
                        <input type="text" class="section-title-input" @bind="section.Title" @bind:event="oninput" @bind:after="AutoSave" placeholder="セクションタイトル" maxlength="90" />
                    </div>

                    <div class="editor-toolbar @(isToolbarExpanded ? "moved" : "")">
                        <button type="button" class="toolbar-btn move" @onclick="() => isToolbarExpanded = !isToolbarExpanded" title="@(isToolbarExpanded ? "ツールバーを戻す" : "ツールバーを展開")">
                            <span>@(isToolbarExpanded ? "≪" : "≫")</span>
                        </button>
                        <div class="toolbar-separator"></div>
                        <button class="toolbar-btn undo" @onclick="Undo" disabled="@(!_canUndo)">⬅</button>
                        <button class="toolbar-btn redo" @onclick="Redo" disabled="@(!_canRedo)">⮕</button>
                        <div class="toolbar-separator"></div>
                        <button class="toolbar-btn @(_formatStates["bold"] ? "active" : "")" @onclick='() => ToggleFormat("bold")' disabled="@_isFormatButtonDisabled"><b>B</b></button>
                        <button class="toolbar-btn @(_formatStates["italic"] ? "active" : "")" @onclick='() => ToggleFormat("italic")' disabled="@_isFormatButtonDisabled"><i>I</i></button>
                        <button class="toolbar-btn @(_formatStates["underline"] ? "active" : "")" @onclick='() => ToggleFormat("underline")' disabled="@_isFormatButtonDisabled"><u>U</u></button>
                        <div class="toolbar-separator"></div>
                        <button class="toolbar-btn" @onclick='() => ApplyFormat("p")'>本文</button>
                        <button class="toolbar-btn" @onclick='() => ApplyFormat("h1")'>H1</button>
                        <button class="toolbar-btn" @onclick='() => ApplyFormat("h2")'>H2</button>
                        <button class="toolbar-btn" @onclick='() => ApplyFormat("h3")'>H3</button>
                        <div class="toolbar-separator"></div>
                        <div class="color-picker-container">
                            <button class="color-indicator-btn" @onclick="ToggleColorPicker">
                                <span class="color-box" style="background-color: @_currentTextColor;"></span>
                            </button>
                            <div class="color-picker-dropdown @(_showColorPicker ? "show" : "")" @onclick:stopPropagation="true">
                                <div class="color-picker-input-wrapper">
                                    <input type="color" class="native-color-picker" @bind="_selectedColor" @bind:event="oninput" />
                                    <input type="text" class="color-input" @bind="_selectedColor" @bind:event="oninput" placeholder="#000000" maxlength="7" />
                                    <button class="color-apply-btn" @onclick="ApplySelectedColor">適用</button>
                                </div>
                                <button class="color-remove-btn" @onclick="RemoveColor">× カラーを戻す</button>

                    @if (_recentColors.Count > 0) {
                                    <div class="recent-colors">
                                        <div class="recent-colors-title">最近使った色</div>
                                        <div class="recent-colors-list">
                                            @foreach (var color in _recentColors) {
                                                <div class="recent-color-option"
                                                     style="background-color: @color;"
                                                     @onclick="() => ApplyRecentColor(color)"
                                                     title="@color"></div>
                                            }
                                        </div>
                                    </div>
                                }
                            </div>
                        </div>
                        <div class="toolbar-separator"></div>
                        <button class="toolbar-btn" @onclick="ShowRubyModal" title="ルビ" disabled="@_isRubyButtonDisabled">ルビ</button>
                        <div class="toolbar-separator"></div>
                        <button class="toolbar-btn" @onclick="InsertQuotes" title="かぎかっこ">｢｣</button>
                        <button class="toolbar-btn" @onclick='() => InsertText("…")' title="三点リーダー">…</button>
                        <button class="toolbar-btn" @onclick='() => InsertText(" ")' title="半角スペース" style="font-weight: bold">␣</button>
                        <button class="toolbar-btn" @onclick='() => InsertText("—")' title="ダッシュ">―</button>
                        <div class="toolbar-separator"></div>
                        <button class="toolbar-btn" @onclick="ClearFormat" style="font-size: 11px;">✕</button>
                    </div>

                    <div style="flex: 1; overflow-y: auto; padding: 10px;">
                        <div @key="@($"{_selectedChapter}-{_selectedSection}")"
                             id="content-editable-mobile"
                             class="content-editable"
                             contenteditable="true"
                             @oninput="OnContentInput"
                             @onkeydown="OnKeyDown">
                        </div>
                    </div>
                    <div id="char-counter-mobile">0文字</div>
                </div>
            }
        } else {
            <div class="mobile-list">
                <div class="mobile-header">
                    <button class="back-btn" @onclick="BackToProjectList">&lt;</button>
                    <div class="mobile-editor-title">プロジェクト一覧に戻る</div>
                </div>
                <div class="mobile-chapter-view">
                    @if (_project.ProjectDataObject?.Scenario?.Chapters == null || _project.ProjectDataObject.Scenario.Chapters.Length == 0) {
                        <div class="empty-message">章がありません</div>
                    } else {
                        @for (int i = 0; i < _project.ProjectDataObject.Scenario.Chapters.Length; i++) {
                            var chapterIndex = i;
                            var chapter = _project.ProjectDataObject.Scenario.Chapters[i];
                            <div class="chapter-item" @key="@($"mobile-chapter-{chapterIndex}")">
                                <div class="chapter-header">
                                    <span class="toggle-icon @(_expandedChapters.Contains(chapterIndex) ? "expanded" : "")" @onclick="() => ToggleChapter(chapterIndex)">
                                        ▶
                                    </span>
                                    <span class="chapter-title" @onclick="() => ToggleChapter(chapterIndex)">
                                        @(string.IsNullOrEmpty(chapter.Title) ? $"Chapter {chapterIndex + 1}" : chapter.Title)
                                    </span>
                                    <button class="add-section-btn" @onclick="() => ShowAddSectionModal(chapterIndex)">+</button>
                                    <button class="settings-btn" @onclick="() => ShowChapterSettings(chapterIndex)">⚙</button>
                                </div>
                                <div class="sections-list @(_expandedChapters.Contains(chapterIndex) ? "expanded" : "")">
                                    @if (chapter.Sections == null || chapter.Sections.Length == 0) {
                                        <div class="empty-message" style="padding: 10px 40px;">話がありません</div>
                                    } else {
                                        @for (int j = 0; j < chapter.Sections.Length; j++) {
                                            var sectionIndex = j;
                                            var section = chapter.Sections[j];
                                            <div class="section-item @(GetDragClass(chapterIndex, sectionIndex))"
                                                 @key="@($"mobile-section-{chapterIndex}-{sectionIndex}")"
                                                 draggable="true"
                                                 @ondragstart="() => HandleDragStart(chapterIndex, sectionIndex)"
                                                 @ondragend="HandleDragEnd"
                                                 @ondragover="(e) => HandleDragOver(e, chapterIndex, sectionIndex)"
                                                 @ondragleave="HandleDragLeave"
                                                 @ondragover:preventDefault="true"
                                                 @ondrop="() => HandleDrop(chapterIndex, sectionIndex)"
                                                 style="display: flex; justify-content: space-between; align-items: center;">
                                                <span style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; padding-right: 5px;" @onclick="() => SelectSectionMobile(chapterIndex, sectionIndex)">
                                                    @(string.IsNullOrEmpty(section.Title) ? $"Section {sectionIndex + 1}" : section.Title)
                                                </span>
                                                <button class="delete-section-btn" style="font-size: 14px; flex-shrink: 0;" @onclick="() => ShowDeleteSectionConfirm(chapterIndex, sectionIndex)">−</button>
                                            </div>
                                        }
                                    }
                                </div>
                            </div>
                        }
                    }
                    <button class="add-chapter-btn" @onclick="ShowAddChapterModal">+ 章を追加</button>
                </div>
            </div>
            <div class="mobile-category-ui">
                <div class="category-select-button active" @onclick='() => SelectCategory("writing")'>執筆</div>
                <div class="category-select-button" @onclick='() => SelectCategory("structure")'>構成</div>
                <div class="category-select-button" @onclick='() => SelectCategory("materials")'>資料</div>
            </div>
        }
    </div>
}

@code {
    [Parameter]
    public int id { get; set; }

    private Project? _project;
    private bool _showCategoryView = false;
    private bool _hasCheckedSessionStorage = false;
    private string _currentCategory = "writing";
    private HashSet<int> _expandedChapters = new HashSet<int>();
    private int _selectedChapter = -1;
    private int _selectedSection = -1;
    private bool _mobileShowEditor = false;
    private static Dictionary<string, Edit> _instances = new Dictionary<string, Edit>();
    private string _instanceId = Guid.NewGuid().ToString();
    private Dictionary<string, bool> _formatStates = new Dictionary<string, bool>
    {
        { "bold", false },
        { "italic", false },
        { "underline", false }
    };
    private System.Threading.Timer? _autoSaveTimer;
    private SemaphoreSlim _saveSemaphore = new SemaphoreSlim(1, 1);
    private bool _isRubyButtonDisabled = false;
    private bool _canUndo = false;
    private bool _canRedo = false;
    private bool _isFormatButtonDisabled = false;
    private bool isToolbarExpanded = false;

    protected override async Task OnInitializedAsync() {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        var appUser = await UserManager.GetUserAsync(user);
        var userId = appUser.Id;

        _project = await DbFactory
            .CreateDbContext()
            .Projects
            .Where(x => x.Id == id && x.UserId == userId)
            .FirstOrDefaultAsync();

        if (_project == null) {
            Nav.NavigateTo("/projects");
        }
    }

    protected override void OnInitialized() {
        base.OnInitialized();
        _instances[_instanceId] = this;
    }

    public void Dispose() {
        try {
            _contentInputTimer?.Dispose();
            _autoSaveTimer?.Dispose();
            _saveSemaphore?.Dispose();

            JSRuntime.InvokeVoidAsync("eval", $@"
            window.blazorConnected = false;
            window['editorEventListenersRegistered_{_instanceId}'] = false;
        ");
        }
        catch {
            // 既に切断されている場合は無視
        }

        _instances.Remove(_instanceId);
    }

    private int _lastRenderedChapter = -1;
    private int _lastRenderedSection = -1;

    private string _currentContentCache = "";
    private bool _isResizing = false;

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            try {
                await JSRuntime.InvokeVoidAsync("initializeEditorEventListeners", _instanceId);
                await JSRuntime.InvokeVoidAsync("setupInputUndoTracking");
                await JSRuntime.InvokeVoidAsync("setBlazorInstance", DotNetObjectReference.Create(this));

                // SessionStorageから遷移元を確認
                if (!_hasCheckedSessionStorage) {
                    var result = await SessionStorage.GetAsync<bool>("fromProjectsList");
                    if (result.Success && result.Value) {
                        _showCategoryView = false;
                        // フラグをクリア
                        await SessionStorage.DeleteAsync("fromProjectsList");
                    } else {
                        _showCategoryView = true;
                    }
                    _hasCheckedSessionStorage = true;
                    StateHasChanged();
                }
            }
            catch (Exception ex) {
                Console.WriteLine($"JavaScript initialization error: {ex.Message}");
            }
        }

        // セクションが変更された場合、またはリサイズ時
        bool sectionChanged = (_selectedChapter != _lastRenderedChapter || _selectedSection != _lastRenderedSection);
        bool needsUpdate = sectionChanged || _isResizing;

        if (needsUpdate &&
            _selectedChapter >= 0 && _selectedSection >= 0 &&
            _project?.ProjectDataObject?.Scenario?.Chapters != null &&
            _selectedChapter < _project.ProjectDataObject.Scenario.Chapters.Length &&
            _project.ProjectDataObject.Scenario.Chapters[_selectedChapter].Sections != null &&
            _selectedSection < _project.ProjectDataObject.Scenario.Chapters[_selectedChapter].Sections.Length) {

            var section = _project.ProjectDataObject.Scenario.Chapters[_selectedChapter].Sections[_selectedSection];

            // 両方のエディタに内容を設定
            await JSRuntime.InvokeVoidAsync("setEditableContent", "content-editable", section.Text ?? "");
            await JSRuntime.InvokeVoidAsync("setEditableContent", "content-editable-mobile", section.Text ?? "");

            var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";
            await JSRuntime.InvokeVoidAsync("updateCharCounterForElement", elementId);

            await JSRuntime.InvokeVoidAsync("adjustContainerHeight");

            _lastRenderedChapter = _selectedChapter;
            _lastRenderedSection = _selectedSection;
            _isResizing = false;
        }
    }

    private bool _sidebarCollapsed = false;

    private void ToggleSidebar() {
        _sidebarCollapsed = !_sidebarCollapsed;
    }

    [JSInvokable("UpdateFormatStates")]
    public static void UpdateFormatStates(string instanceId, Dictionary<string, object> states) {
        if (!_instances.TryGetValue(instanceId, out var instance) || instance == null) {
            return;
        }

        try {
            instance.InvokeAsync(() => {
                // JsonElementから値を取得するヘルパー関数
                bool GetBoolValue(object obj) {
                    if (obj is JsonElement jsonElement) {
                        return jsonElement.GetBoolean();
                    }
                    if (obj is bool boolValue) {
                        return boolValue;
                    }
                    return false;
                }

                string GetStringValue(object obj) {
                    if (obj is JsonElement jsonElement) {
                        return jsonElement.GetString() ?? "#000000";
                    }
                    if (obj is string strValue) {
                        return strValue;
                    }
                    return "#000000";
                }

                if (states.ContainsKey("bold")) {
                    instance._formatStates["bold"] = GetBoolValue(states["bold"]);
                }
                if (states.ContainsKey("italic")) {
                    instance._formatStates["italic"] = GetBoolValue(states["italic"]);
                }
                if (states.ContainsKey("underline")) {
                    instance._formatStates["underline"] = GetBoolValue(states["underline"]);
                }
                if (states.ContainsKey("color")) {
                    instance._currentTextColor = GetStringValue(states["color"]);
                }

                instance.StateHasChanged();
            });
        }
        catch (Exception ex) {
            Console.WriteLine($"UpdateFormatStates error: {ex.Message}");
        }
    }

    [JSInvokable("UpdateRubyButtonState")]
    public static void UpdateRubyButtonState(string instanceId, bool disabled) {
        if (!_instances.TryGetValue(instanceId, out var instance) || instance == null) {
            return;
        }

        try {
            instance.InvokeAsync(() => {
                instance._isRubyButtonDisabled = disabled;
                instance.StateHasChanged();
            });
        }
        catch (Exception ex) {
            Console.WriteLine($"UpdateRubyButtonState error: {ex.Message}");
        }
    }

    private async Task BackToCategoryView() {
        // 現在のセクションを保存
        if (_selectedChapter >= 0 && _selectedSection >= 0) {
            await SaveContent();
            await AutoSave();
        }

        _showCategoryView = false;
        _selectedChapter = -1;
        _selectedSection = -1;
        _lastRenderedChapter = -1;
        _lastRenderedSection = -1;
        _mobileShowEditor = false;

        StateHasChanged();
    }

    private async Task SelectCategory(string category) {
        // 現在のセクションを保存
        if (_selectedChapter >= 0 && _selectedSection >= 0) {
            await SaveContent();
            await AutoSave();
        }

        _currentCategory = category;
        if (category == "writing") {
            _showCategoryView = true;
        } else if (category == "structure") {
            NavigateToStructure(id);
        } else if (category == "materials") {
            NavigateToMaterials(id);
        }

        // 編集画面を閉じる
        _selectedChapter = -1;
        _selectedSection = -1;
        _lastRenderedChapter = -1;
        _lastRenderedSection = -1;
        _mobileShowEditor = false;

        StateHasChanged();
    }

    private void NavigateToStructure(int id) {
        Nav.NavigateTo($"/projects/edit/{id}/structure");
    }

    private void NavigateToMaterials(int id) {
        Nav.NavigateTo($"/projects/edit/{id}/materials");
    }

    private void ToggleChapter(int chapterIndex) {
        if (_expandedChapters.Contains(chapterIndex)) {
            _expandedChapters.Remove(chapterIndex);
        } else {
            _expandedChapters.Add(chapterIndex);
        }
    }

    private async void SelectSection(int chapterIndex, int sectionIndex) {
        // 現在のセクションを保存
        if (_selectedChapter >= 0 && _selectedSection >= 0) {
            await SaveContent();
            await AutoSave();
        }

        _selectedChapter = chapterIndex;
        _selectedSection = sectionIndex;
        ResetFormatStates();

        // Undo/Redoスタックを初期化
        await JSRuntime.InvokeVoidAsync("resetUndoRedoStack");

        // 強制的に再レンダリング
        _lastRenderedChapter = -1;
        _lastRenderedSection = -1;
        StateHasChanged();
    }

    private async void SelectSectionMobile(int chapterIndex, int sectionIndex) {
        // 現在のセクションを保存
        if (_selectedChapter >= 0 && _selectedSection >= 0) {
            await SaveContent();
            await AutoSave();
        }

        _selectedChapter = chapterIndex;
        _selectedSection = sectionIndex;
        _mobileShowEditor = true;
        ResetFormatStates();

        // Undo/Redoスタックを初期化
        await JSRuntime.InvokeVoidAsync("resetUndoRedoStack");

        // 強制的に再レンダリング
        _lastRenderedChapter = -1;
        _lastRenderedSection = -1;

        StateHasChanged();
        await JSRuntime.InvokeVoidAsync("adjustContainerHeight");
    }

    // ドラッグ&ドロップ関連
    private int _dragSourceChapter = -1;
    private int _dragSourceSection = -1;
    private int _dragOverChapter = -1;
    private int _dragOverSection = -1;
    private bool _dragOverBottom = false;

    private void HandleDragStart(int chapterIndex, int sectionIndex) {
        _dragSourceChapter = chapterIndex;
        _dragSourceSection = sectionIndex;
    }

    private void HandleDragEnd() {
        _dragSourceChapter = -1;
        _dragSourceSection = -1;
        _dragOverChapter = -1;
        _dragOverSection = -1;
        _dragOverBottom = false;
    }

    private void HandleDragOver(DragEventArgs e, int chapterIndex, int sectionIndex) {
        if (_dragSourceChapter != chapterIndex) return;

        _dragOverChapter = chapterIndex;
        _dragOverSection = sectionIndex;

        // 要素の高さの半分より下にマウスがある場合は下に挿入
        _dragOverBottom = e.OffsetY > 20; // section-itemの高さの半分程度
    }

    private void HandleDragLeave() {
        _dragOverChapter = -1;
        _dragOverSection = -1;
        _dragOverBottom = false;
    }

    private string GetDragClass(int chapterIndex, int sectionIndex) {
        if (_dragSourceChapter == chapterIndex && _dragSourceSection == sectionIndex) {
            return "dragging";
        }

        if (_dragOverChapter == chapterIndex && _dragOverSection == sectionIndex) {
            return _dragOverBottom ? "drag-over-bottom" : "drag-over-top";
        }

        return "";
    }

    private async Task HandleDrop(int targetChapter, int targetSection) {
        // 章をまたいだ移動は禁止
        if (_dragSourceChapter != targetChapter) {
            HandleDragEnd();
            return;
        }

        // 同じ位置へのドロップは無視
        if (_dragSourceSection == targetSection) {
            HandleDragEnd();
            return;
        }

        if (_project?.ProjectDataObject?.Scenario?.Chapters == null) return;
        if (targetChapter < 0 || targetChapter >= _project.ProjectDataObject.Scenario.Chapters.Length) return;

        var chapter = _project.ProjectDataObject.Scenario.Chapters[targetChapter];
        if (chapter.Sections == null) return;

        var sectionList = chapter.Sections.ToList();
        var draggedSection = sectionList[_dragSourceSection];

        // 元の位置から削除
        sectionList.RemoveAt(_dragSourceSection);

        // 新しい位置に挿入
        int insertIndex = targetSection;

        // ドラッグ元より前の要素にドロップした場合
        if (_dragSourceSection > targetSection) {
            // 上半分なら手前に、下半分なら後ろに挿入
            if (_dragOverBottom) {
                insertIndex++;
            }
        }
        // ドラッグ元より後の要素にドロップした場合
        else {
            // 削除によってインデックスが1つ減っているので調整
            insertIndex--;

            // 下半分なら後ろに挿入
            if (_dragOverBottom) {
                insertIndex++;
            }
        }

        // インデックスの範囲チェック
        if (insertIndex < 0) insertIndex = 0;
        if (insertIndex > sectionList.Count) insertIndex = sectionList.Count;

        sectionList.Insert(insertIndex, draggedSection);
        chapter.Sections = sectionList.ToArray();

        // 選択中のセクションのインデックスを更新
        if (_selectedChapter == targetChapter && _selectedSection == _dragSourceSection) {
            _selectedSection = insertIndex;
        }

        _project.UpdatedAt = DateTime.UtcNow;
        await using var db = DbFactory.CreateDbContext();
        db.Projects.Update(_project);
        await db.SaveChangesAsync();

        HandleDragEnd();
    }

    private async void BackToList() {
        // 保存してからリストに戻る
        await SaveContent();
        await AutoSave();
        _mobileShowEditor = false;
        _selectedChapter = -1;
        _selectedSection = -1;
        _lastRenderedChapter = -1;
        _lastRenderedSection = -1;
        StateHasChanged();
        await JSRuntime.InvokeVoidAsync("adjustContainerHeight");
    }

    private async Task ToggleFormat(string format) {
        _formatStates[format] = !_formatStates[format];
        var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";
        await JSRuntime.InvokeVoidAsync("toggleFormat", elementId, format, _formatStates[format]);
    }

    private async Task ApplyFormat(string format) {
        var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";
        await JSRuntime.InvokeVoidAsync("applyBlockFormat", elementId, format);
    }

    private async Task ClearFormat() {
        var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";
        await JSRuntime.InvokeVoidAsync("clearFormat", elementId);
        ResetFormatStates();
    }

    private void ResetFormatStates() {
        _formatStates["bold"] = false;
        _formatStates["italic"] = false;
        _formatStates["underline"] = false;
    }

    private System.Threading.Timer? _contentInputTimer;
    private bool _hasPendingContentSave = false;

    private async Task OnContentInput() {
        _hasPendingContentSave = true;

        // 既存のタイマーをキャンセル
        _contentInputTimer?.Dispose();

        // 500ms後に保存
        _contentInputTimer = new System.Threading.Timer(async _ => {
            if (_hasPendingContentSave) {
                await InvokeAsync(async () => {
                    try {
                        await SaveContent();
                        ScheduleAutoSave();
                        _hasPendingContentSave = false;
                    }
                    catch (Exception ex) {
                        Console.WriteLine($"OnContentInput error: {ex.Message}");
                    }
                });
            }
        }, null, 500, Timeout.Infinite);

        // 文字カウンターは即座に更新
        var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";
        await JSRuntime.InvokeVoidAsync("updateCharCounterForElement", elementId);
    }

    private async Task CheckRubyButtonState() {
        var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";
        _isRubyButtonDisabled = await JSRuntime.InvokeAsync<bool>("isMixedRubySelection", elementId);
        StateHasChanged();
    }

    private async Task OnKeyDown() {
        // キーボード入力時の処理
    }

    private async Task Undo() {
        var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";
        await JSRuntime.InvokeVoidAsync("undoEditor", elementId);
    }

    private async Task Redo() {
        var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";
        await JSRuntime.InvokeVoidAsync("redoEditor", elementId);
    }

    private async Task BackToProjectList() {
        if (_selectedChapter >= 0 && _selectedSection >= 0) {
            await SaveContent();
        }

        await using var db = DbFactory.CreateDbContext();
        db.Projects.Update(_project);
        await db.SaveChangesAsync();   // ← ここで確定

        _selectedChapter = -1;
        _selectedSection = -1;
        _lastRenderedChapter = -1;
        _lastRenderedSection = -1;

        Nav.NavigateTo("/projects");
    }

    private async Task SaveContent() {
        try {
            string content = "";

            // タイムアウト設定を追加
            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(10));

            // 現在表示されているエディタから内容を取得
            if (_mobileShowEditor) {
                content = await JSRuntime.InvokeAsync<string>("getEditableContent", cts.Token, "content-editable-mobile");
            } else {
                content = await JSRuntime.InvokeAsync<string>("getEditableContent", cts.Token, "content-editable");
            }

            if (_selectedChapter >= 0 && _selectedSection >= 0 &&
                _project?.ProjectDataObject?.Scenario?.Chapters != null &&
                _selectedChapter < _project.ProjectDataObject.Scenario.Chapters.Length &&
                _project.ProjectDataObject.Scenario.Chapters[_selectedChapter].Sections != null &&
                _selectedSection < _project.ProjectDataObject.Scenario.Chapters[_selectedChapter].Sections.Length) {

                // 内容が変わっていない場合はスキップ
                if (_project.ProjectDataObject.Scenario.Chapters[_selectedChapter].Sections[_selectedSection].Text == content) {
                    return;
                }

                _project.ProjectDataObject.Scenario.Chapters[_selectedChapter].Sections[_selectedSection].Text = content;
                _currentContentCache = content;
            }
        }
        catch (OperationCanceledException) {
            Console.WriteLine("SaveContent timeout - content might be too large");
            // タイムアウトの場合は、キャッシュされた内容を使用
            if (_selectedChapter >= 0 && _selectedSection >= 0 &&
                _project?.ProjectDataObject?.Scenario?.Chapters != null &&
                _selectedChapter < _project.ProjectDataObject.Scenario.Chapters.Length &&
                _project.ProjectDataObject.Scenario.Chapters[_selectedChapter].Sections != null &&
                _selectedSection < _project.ProjectDataObject.Scenario.Chapters[_selectedChapter].Sections.Length) {

                // 既にキャッシュがある場合はそれを使用
                if (!string.IsNullOrEmpty(_currentContentCache)) {
                    _project.ProjectDataObject.Scenario.Chapters[_selectedChapter].Sections[_selectedSection].Text = _currentContentCache;
                }
            }
        }
        catch (Exception ex) {
            Console.WriteLine($"SaveContent error: {ex.Message}");
        }
    }

    private void ScheduleAutoSave() {
        _autoSaveTimer?.Dispose();
        _autoSaveTimer = new System.Threading.Timer(async _ => {
            await InvokeAsync(async () => {
                await AutoSave();
            });
        }, null, 1000, Timeout.Infinite);
    }

    private async Task AutoSave() {
        if (!await _saveSemaphore.WaitAsync(0)) {
            return;
        }

        try {
            if (_project != null) {
                _project.UpdatedAt = DateTime.UtcNow;

                // リトライロジック
                int maxRetries = 3;
                for (int i = 0; i < maxRetries; i++) {
                    try {
                        await using var db = DbFactory.CreateDbContext();
                        db.Projects.Update(_project);
                        await db.SaveChangesAsync();
                        break; // 成功したらループを抜ける
                    }
                    catch (Exception ex) when (i < maxRetries - 1) {
                        Console.WriteLine($"AutoSave attempt {i + 1} failed: {ex.Message}");
                        await Task.Delay(500 * (i + 1)); // リトライ前に待機
                    }
                }
            }
        }
        catch (Exception ex) {
            Console.WriteLine($"AutoSave error: {ex.Message}");
        }
        finally {
            _saveSemaphore.Release();
        }
    }

    // モーダル関連の状態
    private bool _showAddChapterModal = false;
    private bool _showAddSectionModal = false;
    private bool _showChapterSettingsModal = false;
    private bool _showDeleteChapterConfirm = false;
    private string _newChapterTitle = "";
    private string _newSectionTitle = "";
    private string _editingChapterTitle = "";
    private int _editingChapterIndex = -1;
    private int _addingSectionToChapterIndex = -1;
    private bool _showDeleteSectionConfirm = false;
    private int _deletingSectionChapterIndex = -1;
    private int _deletingSectionIndex = -1;
    private bool _showRubyModal = false;
    private string _rubyText = "";
    private string _rubyBase = "";
    private bool _isEditingRuby = false;
    private bool _hasSelectedText = false;

    // 章追加モーダル
    private void ShowAddChapterModal() {
        var chapterCount = _project?.ProjectDataObject?.Scenario?.Chapters?.Length ?? 0;
        _newChapterTitle = $"第{chapterCount + 1}章";
        _showAddChapterModal = true;
    }

    private void CloseAddChapterModal() {
        _showAddChapterModal = false;
        _newChapterTitle = "";
    }

    private async Task HandleAddChapterModalKeyDown(KeyboardEventArgs e) {
        if (e.Key == "Enter") {
            await ConfirmAddChapter();
        } else if (e.Key == "Escape") {
            CloseAddChapterModal();
        }
    }

    private async Task ConfirmAddChapter() {
        if (_project?.ProjectDataObject?.Scenario == null) return;

        var newChapter = new Chapter {
            Title = _newChapterTitle
        };

        if (_project.ProjectDataObject.Scenario.Chapters == null) {
            _project.ProjectDataObject.Scenario.Chapters = new[] { newChapter };
        } else {
            var chapterList = _project.ProjectDataObject.Scenario.Chapters.ToList();
            chapterList.Add(newChapter);
            _project.ProjectDataObject.Scenario.Chapters = chapterList.ToArray();
        }

        _project.UpdatedAt = DateTime.UtcNow;
        await using var db = DbFactory.CreateDbContext();
        db.Projects.Update(_project);
        await db.SaveChangesAsync();

        CloseAddChapterModal();
    }

    // 話追加モーダル
    private void ShowAddSectionModal(int chapterIndex) {
        _addingSectionToChapterIndex = chapterIndex;
        var chapter = _project?.ProjectDataObject?.Scenario?.Chapters?[chapterIndex];
        var sectionCount = chapter?.Sections?.Length ?? 0;
        _newSectionTitle = $"第{sectionCount + 1}話";
        _showAddSectionModal = true;
    }

    private void CloseAddSectionModal() {
        _showAddSectionModal = false;
        _newSectionTitle = "";
        _addingSectionToChapterIndex = -1;
    }

    private async Task HandleAddSectionModalKeyDown(KeyboardEventArgs e) {
        if (e.Key == "Enter") {
            await ConfirmAddSection();
        } else if (e.Key == "Escape") {
            CloseAddSectionModal();
        }
    }

    private async Task ConfirmAddSection() {
        if (_project?.ProjectDataObject?.Scenario?.Chapters == null) return;
        if (_addingSectionToChapterIndex < 0 || _addingSectionToChapterIndex >= _project.ProjectDataObject.Scenario.Chapters.Length) return;

        var chapter = _project.ProjectDataObject.Scenario.Chapters[_addingSectionToChapterIndex];
        var newSection = new Section {
            Title = _newSectionTitle,
            Text = ""
        };

        if (chapter.Sections == null) {
            chapter.Sections = new[] { newSection };
        } else {
            var sectionList = chapter.Sections.ToList();
            sectionList.Add(newSection);
            chapter.Sections = sectionList.ToArray();
        }

        _project.UpdatedAt = DateTime.UtcNow;
        await using var db = DbFactory.CreateDbContext();
        db.Projects.Update(_project);
        await db.SaveChangesAsync();

        CloseAddSectionModal();
    }

    // 章設定モーダル
    private void ShowChapterSettings(int chapterIndex) {
        _editingChapterIndex = chapterIndex;
        var chapter = _project?.ProjectDataObject?.Scenario?.Chapters?[chapterIndex];
        _editingChapterTitle = chapter?.Title ?? "";
        _showChapterSettingsModal = true;
    }

    private void CloseChapterSettings() {
        _showChapterSettingsModal = false;
        _editingChapterTitle = "";
        _editingChapterIndex = -1;
    }

    private async Task HandleChapterSettingsKeyDown(KeyboardEventArgs e) {
        if (e.Key == "Enter") {
            await SaveChapterSettings();
        } else if (e.Key == "Escape") {
            CloseChapterSettings();
        }
    }

    private async Task SaveChapterSettings() {
        if (_project?.ProjectDataObject?.Scenario?.Chapters == null) return;
        if (_editingChapterIndex < 0 || _editingChapterIndex >= _project.ProjectDataObject.Scenario.Chapters.Length) return;

        _project.ProjectDataObject.Scenario.Chapters[_editingChapterIndex].Title = _editingChapterTitle;

        _project.UpdatedAt = DateTime.UtcNow;
        await using var db = DbFactory.CreateDbContext();
        db.Projects.Update(_project);
        await db.SaveChangesAsync();

        CloseChapterSettings();
    }

    // 章削除
    private void ShowDeleteChapterConfirm() {
        _showDeleteChapterConfirm = true;
    }

    private void CloseDeleteChapterConfirm() {
        _showDeleteChapterConfirm = false;
    }

    private async Task ConfirmDeleteChapter() {
        if (_project?.ProjectDataObject?.Scenario?.Chapters == null) return;
        if (_editingChapterIndex < 0 || _editingChapterIndex >= _project.ProjectDataObject.Scenario.Chapters.Length) return;

        var chapterList = _project.ProjectDataObject.Scenario.Chapters.ToList();
        chapterList.RemoveAt(_editingChapterIndex);
        _project.ProjectDataObject.Scenario.Chapters = chapterList.ToArray();

        // 削除した章を選択していた場合はリセット
        if (_selectedChapter == _editingChapterIndex) {
            _selectedChapter = -1;
            _selectedSection = -1;
            _lastRenderedChapter = -1;
            _lastRenderedSection = -1;
        } else if (_selectedChapter > _editingChapterIndex) {
            // 削除した章より後ろの章を選択していた場合はインデックスを調整
            _selectedChapter--;
        }

        _project.UpdatedAt = DateTime.UtcNow;
        await using var db = DbFactory.CreateDbContext();
        db.Projects.Update(_project);
        await db.SaveChangesAsync();

        CloseDeleteChapterConfirm();
        CloseChapterSettings();
    }

    private void ShowDeleteSectionConfirm(int chapterIndex, int sectionIndex) {
        _deletingSectionChapterIndex = chapterIndex;
        _deletingSectionIndex = sectionIndex;
        _showDeleteSectionConfirm = true;
    }

    private void CloseDeleteSectionConfirm() {
        _showDeleteSectionConfirm = false;
        _deletingSectionChapterIndex = -1;
        _deletingSectionIndex = -1;
    }

    private async Task ConfirmDeleteSection() {
        if (_project?.ProjectDataObject?.Scenario?.Chapters == null) return;
        if (_deletingSectionChapterIndex < 0 || _deletingSectionChapterIndex >= _project.ProjectDataObject.Scenario.Chapters.Length) return;

        var chapter = _project.ProjectDataObject.Scenario.Chapters[_deletingSectionChapterIndex];
        if (chapter.Sections == null || _deletingSectionIndex < 0 || _deletingSectionIndex >= chapter.Sections.Length) return;

        var sectionList = chapter.Sections.ToList();
        sectionList.RemoveAt(_deletingSectionIndex);
        chapter.Sections = sectionList.ToArray();

        // 削除した話を選択していた場合はリセット
        if (_selectedChapter == _deletingSectionChapterIndex && _selectedSection == _deletingSectionIndex) {
            _selectedChapter = -1;
            _selectedSection = -1;
            _lastRenderedChapter = -1;
            _lastRenderedSection = -1;
            _mobileShowEditor = false;
        } else if (_selectedChapter == _deletingSectionChapterIndex && _selectedSection > _deletingSectionIndex) {
            // 削除した話より後ろの話を選択していた場合はインデックスを調整
            _selectedSection--;
        }

        _project.UpdatedAt = DateTime.UtcNow;
        await using var db = DbFactory.CreateDbContext();
        db.Projects.Update(_project);
        await db.SaveChangesAsync();

        CloseDeleteSectionConfirm();
    }

    private bool _showColorPicker = false;
    private string _selectedColor = "#000000";
    private string _currentTextColor = "#000000";
    private List<string> _recentColors = new List<string>();
    private const int MAX_RECENT_COLORS = 10;

    private async Task ToggleColorPicker() {
        _showColorPicker = !_showColorPicker;

        if (_showColorPicker) {
            var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";
            _currentTextColor = await JSRuntime.InvokeAsync<string>("getCurrentTextColor", elementId);
            _selectedColor = _currentTextColor;
            StateHasChanged();
            await Task.Delay(50);
            await JSRuntime.InvokeVoidAsync("positionColorPickerDropdown");
        }
    }

    private async Task ApplySelectedColor() {
        if (string.IsNullOrEmpty(_selectedColor)) return;

        // カラーコードの正規化
        string color = _selectedColor.Trim();
        if (!color.StartsWith("#")) {
            color = "#" + color;
        }

        await ApplyColor(color);
        AddToRecentColors(color);
    }

    private async Task ApplyRecentColor(string color) {
        _selectedColor = color;
        await ApplyColor(color);
    }

    private async Task ApplyColor(string color) {
        var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";

        try {
            await JSRuntime.InvokeVoidAsync("applyColor", elementId, color);
            _showColorPicker = false;
        }
        catch (Exception ex) {
            Console.WriteLine($"ApplyColor error: {ex.Message}");
        }
    }

    private async Task RemoveColor() {
        var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";

        try {
            await JSRuntime.InvokeVoidAsync("removeColor", elementId);
            _showColorPicker = false;
        }
        catch (Exception ex) {
            Console.WriteLine($"RemoveColor error: {ex.Message}");
        }
    }

    private void AddToRecentColors(string color) {
        // 既に存在する場合は削除
        _recentColors.Remove(color);

        // 先頭に追加
        _recentColors.Insert(0, color);

        // 最大数を超えたら削除
        if (_recentColors.Count > MAX_RECENT_COLORS) {
            _recentColors.RemoveAt(_recentColors.Count - 1);
        }
    }

    //ルビモーダル
    private async Task ShowRubyModal() {
        var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";

        // カーソル位置を保存（editableエリア内でない場合は末尾に移動）
        await JSRuntime.InvokeVoidAsync("saveSelectionForRuby", elementId);

        // 選択範囲がルビと非ルビの混在かチェック
        var isMixedSelection = await JSRuntime.InvokeAsync<bool>("isMixedRubySelection", elementId);

        if (isMixedSelection) {
            // 混在している場合はモーダルを開かない
            return;
        }

        var rubyData = await JSRuntime.InvokeAsync<string[]>("checkRubySelection", elementId);

        if (rubyData != null && rubyData.Length == 2) {
            // ルビ要素を編集
            _isEditingRuby = true;
            _hasSelectedText = false;
            _rubyBase = rubyData[0];
            _rubyText = rubyData[1];
        } else {
            // 新規追加
            _isEditingRuby = false;
            var selectedText = await JSRuntime.InvokeAsync<string>("getSelectedText", elementId);

            if (!string.IsNullOrEmpty(selectedText)) {
                // 選択範囲がある場合
                _hasSelectedText = true;
                _rubyBase = selectedText;
                _rubyText = "";
            } else {
                // カーソル位置に挿入
                _hasSelectedText = false;
                _rubyBase = "";
                _rubyText = "";
            }
        }

        _showRubyModal = true;
    }

    private void CloseRubyModal() {
        _showRubyModal = false;
        _rubyText = "";
        _rubyBase = "";
        _isEditingRuby = false;
        _hasSelectedText = false;
    }

    private async Task HandleRubyModalKeyDown(KeyboardEventArgs e) {
        if (e.Key == "Enter") {
            await ConfirmAddRuby();
        } else if (e.Key == "Escape") {
            CloseRubyModal();
        }
    }

    private async Task ConfirmAddRuby() {
        if (string.IsNullOrEmpty(_rubyText) || string.IsNullOrEmpty(_rubyBase)) {
            CloseRubyModal();
            return;
        }

        var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";

        // 保存した選択範囲を復元
        await JSRuntime.InvokeVoidAsync("restoreSelection", elementId);

        if (_isEditingRuby) {
            await JSRuntime.InvokeVoidAsync("updateRuby", elementId, _rubyBase, _rubyText);
        } else {
            await JSRuntime.InvokeVoidAsync("insertRuby", elementId, _rubyBase, _rubyText, _hasSelectedText);
        }

        CloseRubyModal();
    }

    private async Task ConfirmDeleteRuby() {
        var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";

        await JSRuntime.InvokeVoidAsync("deleteRuby", elementId);

        CloseRubyModal();
    }

    private async Task InsertText(string text) {
        var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";
        await JSRuntime.InvokeVoidAsync("insertTextAtCursor", elementId, text);
    }

    private async Task InsertQuotes() {
        var elementId = _mobileShowEditor ? "content-editable-mobile" : "content-editable";
        await JSRuntime.InvokeVoidAsync("insertQuotesAtCursor", elementId);
    }

    [JSInvokable("OnWindowResize")]
    public static async Task OnWindowResize(string instanceId, int width) {
        if (!_instances.TryGetValue(instanceId, out var instance)) return;

        try {
            await instance.InvokeAsync(async () => {
                bool isMobile = width <= 768;

                if (!isMobile && instance._mobileShowEditor) {
                    await instance.SaveContent();
                    instance._mobileShowEditor = false;
                    instance._isResizing = true;
                } else if (isMobile && !instance._mobileShowEditor &&
                           instance._selectedChapter >= 0 && instance._selectedSection >= 0) {
                    await instance.SaveContent();
                    instance._mobileShowEditor = true;
                    instance._isResizing = true;
                }
                instance.StateHasChanged();
            });
        }
        catch (Exception ex) {
            Console.WriteLine($"OnWindowResize error: {ex.Message}");
        }
    }

    [JSInvokable]
    public void UpdateUndoRedoState(bool canUndo, bool canRedo) {
        _canUndo = canUndo;
        _canRedo = canRedo;
        StateHasChanged();
    }

    [JSInvokable]
    public void UpdateFormatButtonState(bool isDisabled) {
        _isFormatButtonDisabled = isDisabled;
        StateHasChanged();
    }
}

<script>
    (function() {
        if (window.editorScriptLoaded) return;
        window.editorScriptLoaded = true;

        // Blazor接続状態を追跡
        let blazorConnected = true;

        // Blazor切断検知
        if (window.Blazor) {
            Blazor.disconnect = new Proxy(Blazor.disconnect || (() => {}), {
                apply: function(target, thisArg, args) {
                    blazorConnected = false;
                    return target.apply(thisArg, args);
                }
            });
        }

        // 安全なDotNet呼び出しヘルパー
        function safeDotNetInvoke(methodName, ...args) {
            if (!blazorConnected) {
                return Promise.resolve();
            }

            try {
                return DotNet.invokeMethodAsync('StoryDesignSupportWebApp', methodName, ...args);
            } catch (e) {
                console.warn('DotNet invoke failed:', e);
                return Promise.resolve();
            }
        }

        window.initializeEditorEventListeners = function(instanceId) {
            if (window['editorEventListenersRegistered_' + instanceId]) return;
            window['editorEventListenersRegistered_' + instanceId] = true;

            window.addEventListener('formatStateChanged', function(e) {
                if (!window.blazorConnected) return;
                try {
                    DotNet.invokeMethodAsync('StoryDesignSupportWebApp', 'UpdateFormatStates', instanceId, e.detail);
                } catch (err) {
                    console.warn('UpdateFormatStates failed:', err);
                }
            });

            window.addEventListener('rubyButtonStateChanged', function(e) {
                if (!window.blazorConnected) return;
                try {
                    DotNet.invokeMethodAsync('StoryDesignSupportWebApp', 'UpdateRubyButtonState', instanceId, e.detail.disabled);
                } catch (err) {
                    console.warn('UpdateRubyButtonState failed:', err);
                }
            });

            // カラーピッカー外クリックイベント
            if (!window.colorPickerClickListenerRegistered) {
                window.colorPickerClickListenerRegistered = true;

                document.addEventListener('click', function(e) {
                    const colorPickers = document.querySelectorAll('.color-picker-container');
                    colorPickers.forEach(picker => {
                        if (!picker.contains(e.target)) {
                            const dropdown = picker.querySelector('.color-picker-dropdown');
                            if (dropdown && dropdown.classList.contains('show')) {
                                dropdown.classList.remove('show');
                            }
                        }
                    });
                });
            }

            // リサイズ検知
            let resizeTimer;
            window.addEventListener('resize', function() {
                if (!window.blazorConnected) return;
                clearTimeout(resizeTimer);
                resizeTimer = setTimeout(function() {
                    if (!window.blazorConnected) return;
                    try {
                        DotNet.invokeMethodAsync('StoryDesignSupportWebApp', 'OnWindowResize', instanceId, window.innerWidth);
                    } catch (err) {
                        console.warn('OnWindowResize failed:', err);
                    }
                }, 300);
            });

            // ヘッダーの高さに応じてコンテナの高さを調整
            function adjustContainerHeight() {
                const topRow = document.querySelector('.top-row');
                const desktopContainer = document.querySelector('.edit-container.desktop-view');
                const mobileContainer = document.querySelector('.mobile-view');
                const mobileView = document.querySelector('.mobile-list');
                const mobileEditor = document.querySelector('.mobile-editor');

                if (topRow) {
                    const isCollapsed = topRow.classList.contains('collapsed');
                    const height = isCollapsed ? 'calc(100vh - 2rem)' : 'calc(100vh - 5.5rem)';

                    if (desktopContainer) desktopContainer.style.height = height;
                    if (mobileContainer) mobileContainer.style.height = height;
                    if (mobileView) mobileView.style.height = height;
                    if (mobileEditor) mobileEditor.style.height = height;
                }
            }

            // 初回調整
            adjustContainerHeight();

            window.adjustContainerHeight = adjustContainerHeight;

            // MutationObserverでヘッダーの変更を監視
            const observer = new MutationObserver(adjustContainerHeight);
            const topRow = document.querySelector('.top-row');
            if (topRow) {
                observer.observe(topRow, { attributes: true, attributeFilter: ['class'] });
            }

            // Blazor接続状態の初期化
            window.blazorConnected = true;
        };

        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STACK = 100;
        let inputTimeout = null;
        let lastSavedContent = {};

        window.setBlazorInstance = function(instance) {
            window.blazorInstance = instance;
        };

        function notifyUndoRedoStates() {
            const canUndo = undoStack.length > 0;
            const canRedo = redoStack.length > 0;

            if (window.blazorInstance) {
                window.blazorInstance.invokeMethodAsync('UpdateUndoRedoState', canUndo, canRedo);
            }
        }

        window.resetUndoRedoStack = function() {
            undoStack = [];
            redoStack = [];
            lastSavedContent = {};

            // Undo/Redo状態を通知
            notifyUndoRedoStates();
        };

        function saveUndoState(elementId, force = false) {
            const element = document.getElementById(elementId);
            if (!element) return;

            const currentContent = element.innerHTML;

            // lastSavedContentが未定義の場合は初期化
            if (lastSavedContent[elementId] === undefined) {
                lastSavedContent[elementId] = currentContent;
                if (!force) return;
            }

            // 内容が変わっている場合、または強制保存の場合
            if (force || lastSavedContent[elementId] !== currentContent) {
                const state = {
                    html: force ? currentContent : lastSavedContent[elementId],
                    selection: saveSelectionState(element)
                };
                undoStack.push(state);
                if (undoStack.length > MAX_UNDO_STACK) {
                    undoStack.shift();
                }
                redoStack = []; // 新しい操作でredoスタックをクリア

                lastSavedContent[elementId] = currentContent;
                notifyUndoRedoStates();
            }
        }

        function saveSelectionState(element) {
            const selection = window.getSelection();
            if (!selection || selection.rangeCount === 0) return null;

            const range = selection.getRangeAt(0);

            function getNodePath(node) {
                if (!node) return [];
                const path = [];
                while (node && node !== element) {
                    const parent = node.parentNode;
                    if (!parent) break;
                    const index = Array.from(parent.childNodes).indexOf(node);
                    path.unshift(index);
                    node = parent;
                }
                return path;
            }

            try {
                return {
                    startPath: getNodePath(range.startContainer),
                    startOffset: range.startOffset,
                    endPath: getNodePath(range.endContainer),
                    endOffset: range.endOffset
                };
            } catch (e) {
                console.warn('Failed to save selection state:', e);
                return null;
            }
        }

        function restoreSelectionState(element, selectionState) {
            if (!selectionState || !element) return;

            function getNodeFromPath(path) {
                if (!path || path.length === 0) return element;
                let node = element;
                for (const index of path) {
                    if (!node || !node.childNodes || !node.childNodes[index]) {
                        return null;
                    }
                    node = node.childNodes[index];
                }
                return node;
            }

            try {
                const startNode = getNodeFromPath(selectionState.startPath);
                const endNode = getNodeFromPath(selectionState.endPath);

                if (!startNode || !endNode) return;

                const range = document.createRange();
                range.setStart(startNode, Math.min(selectionState.startOffset, startNode.length || startNode.childNodes?.length || 0));
                range.setEnd(endNode, Math.min(selectionState.endOffset, endNode.length || endNode.childNodes?.length || 0));

                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
            } catch (e) {
                console.warn('Selection restore failed:', e);
            }
        }

        window.undoEditor = function(elementId) {
            const element = document.getElementById(elementId);
            if (!element || undoStack.length === 0) return;

            // undoスタックから状態を取得
            const state = undoStack.pop();

            // 現在の状態をredoスタックに保存
            redoStack.push({
                html: element.innerHTML,
                selection: saveSelectionState(element)
            });

            // 状態を復元
            element.innerHTML = state.html;

            // カーソル位置を復元
            if (state.selection) {
                restoreSelectionState(element, state.selection);
            }

            // 最後に保存した内容を更新
            lastSavedContent[elementId] = state.html;

            element.focus();

            // Undo/Redo状態を通知
            notifyUndoRedoStates();
        };

        window.redoEditor = function(elementId) {
            const element = document.getElementById(elementId);
            if (!element || redoStack.length === 0) return;

            // 現在の状態をundoスタックに保存
            const currentHtml = element.innerHTML;
            const currentSelection = saveSelectionState(element);

            undoStack.push({
                html: currentHtml,
                selection: currentSelection
            });

            // redoスタックから状態を復元
            const state = redoStack.pop();
            element.innerHTML = state.html;

            // カーソル位置を復元
            if (state.selection) {
                restoreSelectionState(element, state.selection);
            }

            // 最後に保存した内容を更新
            lastSavedContent[elementId] = state.html;

            element.focus();

            // Undo/Redo状態を通知
            notifyUndoRedoStates();
        };

        // ルビと非ルビが混在する選択範囲かチェック
        window.isMixedRubySelection = function(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return false;

            const selection = window.getSelection();
            if (selection.rangeCount === 0 || selection.isCollapsed) return false;

            const range = selection.getRangeAt(0);

            // 選択範囲内のすべてのruby要素を取得
            const allRubiesInDoc = element.querySelectorAll('ruby');
            let fullySelectedRubies = [];
            let partiallySelectedRubies = [];

            allRubiesInDoc.forEach(ruby => {
                if (range.intersectsNode(ruby)) {
                    const rubyRange = document.createRange();
                    rubyRange.selectNode(ruby);

                    const fullyContained =
                        range.compareBoundaryPoints(Range.START_TO_START, rubyRange) <= 0 &&
                        range.compareBoundaryPoints(Range.END_TO_END, rubyRange) >= 0;

                    if (fullyContained) {
                        fullySelectedRubies.push(ruby);
                    } else {
                        partiallySelectedRubies.push(ruby);
                    }
                }
            });

            // 部分的に選択されているruby要素がある場合は混在とみなす（ボタン無効）
            if (partiallySelectedRubies.length > 0) {
                return true;
            }

            // 選択範囲内のテキストを取得（ruby要素のrt部分を除く）
            const fragment = range.cloneContents();
            const tempDiv = document.createElement('div');
            tempDiv.appendChild(fragment);

            // rt要素を削除
            const rtElements = tempDiv.querySelectorAll('rt');
            rtElements.forEach(rt => rt.remove());

            // 完全に選択されているruby要素のテキストを除去
            fullySelectedRubies.forEach(() => {
                const rubies = tempDiv.querySelectorAll('ruby');
                if (rubies.length > 0) {
                    rubies[0].remove();
                }
            });

            // 残りのテキストをチェック（ゼロ幅スペースと空白を除く）
            const remainingText = tempDiv.textContent.replace(/\u200B/g, '').replace(/\s/g, '');

            // ルビ要素が1つ以上あり、かつ他のテキストもある場合は混在（ボタン無効）
            // ルビ要素のみ、または通常テキストのみの場合はOK（ボタン有効）
            return fullySelectedRubies.length > 0 && remainingText.length > 0;
        };

        let currentFormat = {
            bold: false,
            italic: false,
            underline: false
        };

        window.setEditableContent = function(elementId, content) {
            const element = document.getElementById(elementId);
            if (!element) return; // 要素が存在しない場合は何もしない

            if (element.innerHTML !== (content || '')) {
                element.innerHTML = content || '';

                const selection = window.getSelection();
                const range = document.createRange();

                if (element.childNodes.length > 0) {
                    range.setStart(element.childNodes[0], 0);
                    range.collapse(true);
                } else {
                    range.selectNodeContents(element);
                    range.collapse(true);
                }

                selection.removeAllRanges();
                selection.addRange(range);
            }
        };

        window.getEditableContent = function(elementId) {
            const element = document.getElementById(elementId);
            return element ? element.innerHTML : '';
        };

        // 特定のエディタの文字数をカウント
        window.updateCharCounterForElement = function(elementId) {
            const editor = document.getElementById(elementId);

            if (!editor) return;

            const count = countPlainTextCharacters(editor);

            // モバイルかPCかで更新するカウンターを分ける
            if (elementId === 'content-editable-mobile') {
                const counter = document.getElementById("char-counter-mobile");
                if (counter) {
                    counter.textContent = `${count}文字`;
                }
            } else {
                const counter = document.getElementById("char-counter");
                if (counter) {
                    counter.textContent = `${count}文字`;
                }
            }
        };

        function countPlainTextCharacters(root) {
            let count = 0;

            const walker = document.createTreeWalker(
                root,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode(node) {
                        // ruby / rt 内のテキストは除外
                        if (node.parentElement?.closest('ruby')) {
                            return NodeFilter.FILTER_REJECT;
                        }
                        return NodeFilter.FILTER_ACCEPT;
                    }
                }
            );

            while (walker.nextNode()) {
                const text = walker.currentNode.textContent
                    .replace(/\u200B/g, '')   // ゼロ幅スペース除外
                    .replace(/\s/g, '');      // 空白除外

                count += text.length;
            }

            return count;
        }

        // 選択状態とフォーカス状態の変更を監視
        let debounceTimer = null;
        let formatStateTimer = null;

        document.addEventListener('selectionchange', function() {
            if (!blazorConnected) return;

            // 前のタイマーをクリア
            if (debounceTimer) {
                clearTimeout(debounceTimer);
            }

            // 50msに短縮（元は100ms）
            debounceTimer = setTimeout(function() {
                if (!blazorConnected) return;

                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    // 常にフォーマット状態を更新
                    updateFormatStates();

                    // ルビボタンの状態をチェック
                    const activeElement = document.activeElement;
                    if (activeElement && (activeElement.id === 'content-editable' || activeElement.id === 'content-editable-mobile')) {
                        try {
                            const isMixed = window.isMixedRubySelection(activeElement.id);
                            window.dispatchEvent(new CustomEvent('rubyButtonStateChanged', {
                                detail: { disabled: isMixed }
                            }));

                            // フォーマットボタンの状態をチェック（ルビが選択されているか）
                            const rubySelection = window.checkRubySelection(activeElement.id);
                            const hasRubySelected = rubySelection !== null || isMixed;
                            if (window.blazorInstance) {
                                window.blazorInstance.invokeMethodAsync('UpdateFormatButtonState', hasRubySelected);
                            }
                        } catch (e) {
                            console.warn('Selection check failed:', e);
                        }
                    }
                }
            }, 50);
        });

        function updateFormatStates() {
            if (!blazorConnected) return;

            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;

            const range = selection.getRangeAt(0);

            if (selection.isCollapsed) {
                // カーソル位置のみの場合
                const node = range.startContainer;
                const parentElement = node.nodeType === 3 ? node.parentElement : node;

                if (!parentElement || parentElement.nodeType !== 1) return;

                currentFormat.bold = hasParentTag(parentElement, 'B') || hasParentTag(parentElement, 'STRONG');
                currentFormat.italic = hasParentTag(parentElement, 'I') || hasParentTag(parentElement, 'EM');
                currentFormat.underline = hasParentTag(parentElement, 'U');
            } else {
                // 選択範囲がある場合
                currentFormat.bold = document.queryCommandState('bold');
                currentFormat.italic = document.queryCommandState('italic');
                currentFormat.underline = document.queryCommandState('underline');
            }

            notifyFormatStates();
        }

        function hasParentTag(element, tagName) {
            // elementがnullまたは要素でない場合の処理を追加
            if (!element) return false;

            // テキストノードの場合は親要素を取得
            if (element.nodeType === 3) {
                element = element.parentElement;
            }

            // 要素でない場合はfalseを返す
            if (!element || element.nodeType !== 1) return false;

            while (element && element.nodeName !== 'DIV' && !element.hasAttribute('contenteditable')) {
                if (element.nodeName === tagName) return true;
                element = element.parentElement;
            }
            return false;
        }

        function notifyFormatStates() {
            if (!blazorConnected) return;

            // debounceでまとめて送信
            if (formatStateTimer) {
                clearTimeout(formatStateTimer);
            }

            formatStateTimer = setTimeout(function() {
                if (!blazorConnected) return;

                try {
                    // 現在の色を取得
                    const elementId = document.getElementById('content-editable') ? 'content-editable' : 'content-editable-mobile';
                    const currentColor = window.getCurrentTextColor(elementId);

                    const stateData = { ...currentFormat, color: currentColor };

                    window.dispatchEvent(new CustomEvent('formatStateChanged', {
                        detail: stateData
                    }));
                } catch (e) {
                    console.warn('Format state notification failed:', e);
                }
            }, 50);
        }

        window.toggleFormat = function(elementId, format, isActive) {
            const element = document.getElementById(elementId);
            if (!element) return;

            saveUndoState(elementId);

            const scrollTop = element.scrollTop;
            element.focus();
            const selection = window.getSelection();

            if (selection.rangeCount > 0 && !selection.isCollapsed) {
                // テキストが選択されている場合
                document.execCommand(format, false, null);

                // 選択を解除するが、書式状態は変更しない（チカチカ防止）
                setTimeout(() => {
                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        range.collapse(false);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                    element.scrollTop = scrollTop;
                }, 10);
            } else {
                // 選択されていない場合
                currentFormat[format] = isActive;

                const range = selection.getRangeAt(0);
                const tagName = format === 'bold' ? 'B' : format === 'italic' ? 'I' : 'U';
                const node = range.startContainer;
                const parentElement = node.nodeType === 3 ? node.parentElement : node;
                const hasFormat = hasParentTag(parentElement, tagName);

                if (isActive && !hasFormat) {
                    // フォーマットを適用
                    const formatNode = document.createElement(tagName.toLowerCase());
                    const dummyNode = document.createTextNode('\u200B');
                    formatNode.appendChild(dummyNode);
                    range.insertNode(formatNode);
                    range.setStart(dummyNode, 1);
                } else if (!isActive && hasFormat) {
                    // フォーマットを解除 - フォーマット範囲の外に移動
                    let formatElement = parentElement;
                    while (formatElement && formatElement !== element) {
                        if (formatElement.nodeName === tagName) {
                            break;
                        }
                        formatElement = formatElement.parentElement;
                    }

                    if (formatElement && formatElement.nodeName === tagName) {
                        const dummyNode = document.createTextNode('\u200B');
                        if (formatElement.nextSibling) {
                            formatElement.parentNode.insertBefore(dummyNode, formatElement.nextSibling);
                        } else {
                            formatElement.parentNode.appendChild(dummyNode);
                        }
                        range.setStart(dummyNode, 1);
                    }
                } else {
                    // 状態が一致している場合はゼロ幅スペースを挿入
                    const dummyNode = document.createTextNode('\u200B');
                    range.insertNode(dummyNode);
                    range.setStart(dummyNode, 1);
                }

                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);

                notifyFormatStates();
                element.scrollTop = scrollTop;
            }
        };

        // カラー適用関数
        window.applyColor = function(elementId, color) {
            const element = document.getElementById(elementId);
            if (!element) {
                console.warn('Element not found:', elementId);
                return;
            }

            element.focus();

            const selection = window.getSelection();
            if (!selection || selection.rangeCount === 0) {
                console.warn('No selection available');
                return;
            }

            try {
                saveUndoState(elementId);
            } catch (e) {
                console.warn('Failed to save undo state:', e);
            }

            const scrollTop = element.scrollTop;

            if (!selection.isCollapsed) {
                const range = selection.getRangeAt(0);
                const span = document.createElement('span');
                span.style.color = color;

                try {
                    const contents = range.extractContents();
                    span.appendChild(contents);
                    range.insertNode(span);

                    // カラー適用範囲の直後にゼロ幅スペースを追加して移動
                    const after = document.createTextNode('\u200B');
                    range.setStartAfter(span);
                    range.insertNode(after);
                    range.setStart(after, 1);
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);
                } catch (e) {
                    console.error('Failed to apply color to selection:', e);
                }
            } else {
                try {
                    const range = selection.getRangeAt(0);
                    const span = document.createElement('span');
                    span.style.color = color;
                    const dummyNode = document.createTextNode('\u200B');
                    span.appendChild(dummyNode);

                    range.insertNode(span);
                    range.setStart(dummyNode, 1);
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);
                } catch (e) {
                    console.error('Failed to apply color at cursor:', e);
                }
            }

            element.scrollTop = scrollTop;
        };

        // カラー解除関数
        window.removeColor = function(elementId) {
            const element = document.getElementById(elementId);
            if (!element) {
                console.warn('Element not found:', elementId);
                return;
            }

            element.focus();

            const selection = window.getSelection();
            if (!selection || selection.rangeCount === 0) {
                console.warn('No selection available');
                return;
            }

            try {
                saveUndoState(elementId);
            } catch (e) {
                console.warn('Failed to save undo state:', e);
            }

            const scrollTop = element.scrollTop;

            if (!selection.isCollapsed) {
                // 選択範囲がある場合
                try {
                    const range = selection.getRangeAt(0);
                    const fragment = range.extractContents();
                    const tempDiv = document.createElement('div');
                    tempDiv.appendChild(fragment);

                    const colorSpans = tempDiv.querySelectorAll('span[style*="color"]');
                    colorSpans.forEach(span => {
                        span.style.color = '';
                        if (!span.getAttribute('style') || span.getAttribute('style').trim() === '') {
                            const parent = span.parentNode;
                            while (span.firstChild) {
                                parent.insertBefore(span.firstChild, span);
                            }
                            parent.removeChild(span);
                        }
                    });

                    while (tempDiv.firstChild) {
                        range.insertNode(tempDiv.lastChild);
                    }

                    range.collapse(false);
                    selection.removeAllRanges();
                    selection.addRange(range);
                } catch (e) {
                    console.error('Failed to remove color from selection:', e);
                }
            } else {
                // カーソル位置のみの場合 - カラー範囲外に移動
                try {
                    const range = selection.getRangeAt(0);
                    let node = range.startContainer;
                    if (node.nodeType === 3) {
                        node = node.parentElement;
                    }

                    let colorSpan = null;
                    while (node && node !== element) {
                        if (node.nodeName === 'SPAN' && node.style.color) {
                            colorSpan = node;
                            break;
                        }
                        node = node.parentElement;
                    }

                    if (colorSpan) {
                        // カラー範囲の直後にゼロ幅スペースを追加して移動
                        const after = document.createTextNode('\u200B');
                        if (colorSpan.nextSibling) {
                            colorSpan.parentNode.insertBefore(after, colorSpan.nextSibling);
                        } else {
                            colorSpan.parentNode.appendChild(after);
                        }

                        range.setStart(after, 1);
                        range.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                } catch (e) {
                    console.error('Failed to remove color at cursor:', e);
                }
            }

            element.scrollTop = scrollTop;
        };

        window.insertTextAtCursor = function(elementId, text) {
            const element = document.getElementById(elementId);
            if (!element) return;

            saveUndoState(elementId);

            element.focus();
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;

            const range = selection.getRangeAt(0);

            // 半角スペースの場合は特別処理
            if (text === ' ') {
                // ノーブレークスペース(&nbsp;)を使用
                const textNode = document.createTextNode('\u00A0');

                range.deleteContents();
                range.insertNode(textNode);

                // カーソルを挿入したテキストの後ろに移動
                range.setStartAfter(textNode);
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);
            } else {
                const textNode = document.createTextNode(text);

                range.deleteContents();
                range.insertNode(textNode);

                // カーソルを挿入したテキストの後ろに移動
                range.setStartAfter(textNode);
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);
            }
        };

        window.insertQuotesAtCursor = function(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return;

            saveUndoState(elementId);

            element.focus();
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;

            const range = selection.getRangeAt(0);

            if (!selection.isCollapsed) {
                // 選択範囲がある場合
                const selectedContent = range.extractContents();
                const fragment = document.createDocumentFragment();

                fragment.appendChild(document.createTextNode('「'));
                fragment.appendChild(selectedContent);
                fragment.appendChild(document.createTextNode('」'));

                range.insertNode(fragment);
                range.collapse(false);
            } else {
                // 選択範囲がない場合
                const textNode = document.createTextNode('「」');
                range.insertNode(textNode);

                // カーソルを「」の間に移動
                range.setStart(textNode, 1);
                range.collapse(true);
            }

            selection.removeAllRanges();
            selection.addRange(range);
        };

        window.applyBlockFormat = function(elementId, format) {
            const element = document.getElementById(elementId);
            if (!element) return;

            saveUndoState(elementId);

            const scrollTop = element.scrollTop;
            element.focus();
            const selection = window.getSelection();

            if (selection.rangeCount > 0) {
                if (selection.isCollapsed) {
                    const range = selection.getRangeAt(0);
                    const currentNode = range.startContainer;
                    let blockElement = currentNode.nodeType === 3 ? currentNode.parentElement : currentNode;

                    while (blockElement && blockElement !== element && !isBlockElement(blockElement)) {
                        blockElement = blockElement.parentElement;
                    }

                    if (blockElement === element) {
                        const newElement = document.createElement(format);
                        newElement.innerHTML = '<br>';
                        newElement.style.lineHeight = '';
                        element.appendChild(newElement);

                        const newRange = document.createRange();
                        newRange.setStart(newElement, 0);
                        newRange.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(newRange);
                    } else if (blockElement) {
                        const offset = getCaretOffset(blockElement, range);

                        const newElement = document.createElement(format);
                        newElement.innerHTML = blockElement.innerHTML || '<br>';
                        newElement.style.lineHeight = '';
                        blockElement.parentNode.replaceChild(newElement, blockElement);

                        restoreCaretOffset(newElement, offset);
                    }
                    element.scrollTop = scrollTop;
                } else {
                    document.execCommand('formatBlock', false, format);

                    // 選択を解除
                    setTimeout(() => {
                        if (selection.rangeCount > 0) {
                            const range = selection.getRangeAt(0);
                            range.collapse(false);
                            selection.removeAllRanges();
                            selection.addRange(range);
                        }
                        element.focus();
                        element.scrollTop = scrollTop;
                    }, 10);
                }
            }
        };

        function isBlockElement(element) {
            const blockTags = ['P', 'DIV', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'BLOCKQUOTE', 'PRE'];
            return blockTags.includes(element.nodeName);
        }

        function getCaretOffset(element, range) {
            const preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(element);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            return preCaretRange.toString().length;
        }

        function restoreCaretOffset(element, offset) {
            const selection = window.getSelection();
            const range = document.createRange();

            let currentPos = 0;
            let found = false;

            function searchNode(node) {
                if (found) return;

                if (node.nodeType === 3) {
                    const nodeLength = node.textContent.length;
                    if (currentPos + nodeLength >= offset) {
                        range.setStart(node, offset - currentPos);
                        range.collapse(true);
                        found = true;
                        return;
                    }
                    currentPos += nodeLength;
                } else if (node.nodeName === 'BR') {
                    currentPos += 1;
                    if (currentPos >= offset) {
                        range.setStartAfter(node);
                        range.collapse(true);
                        found = true;
                        return;
                    }
                } else {
                    for (let i = 0; i < node.childNodes.length; i++) {
                        searchNode(node.childNodes[i]);
                        if (found) return;
                    }
                }
            }

            searchNode(element);

            if (found) {
                selection.removeAllRanges();
                selection.addRange(range);
            } else {
                // 位置が見つからない場合は最後に設定
                range.selectNodeContents(element);
                range.collapse(false);
                selection.removeAllRanges();
                selection.addRange(range);
            }

            element.focus();
        }

        // 選択範囲を保存する変数
        let savedSelection = null;

        window.saveSelection = function(elementId) {
            // この関数は他の用途で使われている可能性があるので残す
            const element = document.getElementById(elementId);
            if (!element) return;

            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                savedSelection = {
                    range: selection.getRangeAt(0).cloneRange(),
                    elementId: elementId
                };
            }
        };

        window.restoreSelection = function(elementId) {
            const element = document.getElementById(elementId);
            if (!element || !savedSelection || savedSelection.elementId !== elementId) return;

            element.focus();
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(savedSelection.range);
        };

        window.getSelectedText = function(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return '';

            const selection = window.getSelection();
            if (selection.rangeCount > 0 && !selection.isCollapsed) {
                const range = selection.getRangeAt(0);
                // ruby要素内のテキストを除外
                const fragment = range.cloneContents();
                const temp = document.createElement('div');
                temp.appendChild(fragment);

                // rt要素を削除
                const rtElements = temp.querySelectorAll('rt');
                rtElements.forEach(rt => rt.remove());

                return temp.textContent;
            }
            return '';
        };

        window.insertRuby = function(elementId, baseText, rubyText, hasSelectedText) {
            const element = document.getElementById(elementId);
            if (!element) return;

            saveUndoState(elementId);

            const scrollTop = element.scrollTop;
            const selection = window.getSelection();

            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);

                const cursorNode = range.startContainer;

                // 選択範囲内の既存ruby要素を削除
                if (!selection.isCollapsed) {
                    const fragment = range.cloneContents();
                    const tempDiv = document.createElement('div');
                    tempDiv.appendChild(fragment);

                    if (tempDiv.querySelector('ruby')) {
                        const actualRange = range.cloneRange();
                        const rubysToDelete = [];

                        const walker = document.createTreeWalker(
                            actualRange.commonAncestorContainer,
                            NodeFilter.SHOW_ELEMENT,
                            {
                                acceptNode: function(node) {
                                    if (node.nodeName === 'RUBY' && actualRange.intersectsNode(node)) {
                                        return NodeFilter.FILTER_ACCEPT;
                                    }
                                    return NodeFilter.FILTER_SKIP;
                                }
                            }
                        );

                        let node;
                        while (node = walker.nextNode()) {
                            rubysToDelete.push(node);
                        }

                        rubysToDelete.forEach(ruby => {
                            const prevNode = ruby.previousSibling;
                            const nextNode = ruby.nextSibling;

                            if (prevNode && prevNode.nodeType === 3 && prevNode.textContent === '\u200B') {
                                prevNode.remove();
                            }
                            if (nextNode && nextNode.nodeType === 3 && nextNode.textContent === '\u200B') {
                                nextNode.remove();
                            }

                            ruby.remove();
                        });
                    }

                    range.deleteContents();
                }

                // 新しいruby要素を作成
                const ruby = document.createElement('ruby');
                ruby.textContent = baseText;

                const rt = document.createElement('rt');
                rt.textContent = rubyText;
                ruby.appendChild(rt);

                const before = document.createTextNode('\u200B');
                const after = document.createTextNode('\u200B');

                range.insertNode(after);
                range.insertNode(ruby);
                range.insertNode(before);

                range.setStart(after, 1);
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);

                if (cursorNode.nodeType === 3) {
                    cursorNode.parentElement?.scrollIntoView({ block: 'center', inline: 'nearest' });
                } else {
                    cursorNode.scrollIntoView?.({ block: 'center', inline: 'nearest' });
                }
            }
            savedSelection = null;
        };

        window.updateRuby = function(elementId, baseText, rubyText) {
            const element = document.getElementById(elementId);
            if (!element) return;

            saveUndoState(elementId);

            const scrollTop = element.scrollTop;
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;

            const range = selection.getRangeAt(0);

            // 選択されているruby要素を取得
            let rubyElement = null;

            if (range.startContainer.nodeType === 1 &&
                range.startContainer.childNodes[range.startOffset]?.nodeName === 'RUBY') {
                rubyElement = range.startContainer.childNodes[range.startOffset];
            } else {
                let node = range.commonAncestorContainer;
                if (node.nodeType === 3) {
                    node = node.parentElement;
                }

                let currentNode = node;
                while (currentNode && currentNode !== element) {
                    if (currentNode.nodeName === 'RUBY') {
                        rubyElement = currentNode;
                        break;
                    }
                    currentNode = currentNode.parentElement;
                }
            }

            if (rubyElement) {
                // 新しいruby要素を作成
                const newRuby = document.createElement('ruby');
                newRuby.textContent = baseText;

                const rt = document.createElement('rt');
                rt.textContent = rubyText;
                newRuby.appendChild(rt);

                // 古いruby要素を置き換え
                rubyElement.parentNode.replaceChild(newRuby, rubyElement);

                // カーソルをルビの後ろに移動
                const afterNode = newRuby.nextSibling;
                if (afterNode && afterNode.nodeType === 3 && afterNode.textContent === '\u200B') {
                    const newRange = document.createRange();
                    newRange.setStart(afterNode, 1);
                    newRange.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                } else {
                    const after = document.createTextNode('\u200B');
                    if (newRuby.nextSibling) {
                        newRuby.parentNode.insertBefore(after, newRuby.nextSibling);
                    } else {
                        newRuby.parentNode.appendChild(after);
                    }

                    const newRange = document.createRange();
                    newRange.setStart(after, 1);
                    newRange.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                }
            }
            if (selection.rangeCount > 0) {
                const currentRange = selection.getRangeAt(0);
                const cursorNode = currentRange.startContainer;
                if (cursorNode.nodeType === 3) {
                    cursorNode.parentElement?.scrollIntoView({ block: 'center', inline: 'nearest' });
                } else {
                    cursorNode.scrollIntoView?.({ block: 'center', inline: 'nearest' });
                }
            }
            savedSelection = null;
        };

        window.deleteRuby = function(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return;

            saveUndoState(elementId);

            const scrollTop = element.scrollTop;
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;

            const range = selection.getRangeAt(0);

            // 選択されているruby要素を取得
            let rubyElement = null;

            if (range.startContainer.nodeType === 1 &&
                range.startContainer.childNodes[range.startOffset]?.nodeName === 'RUBY') {
                rubyElement = range.startContainer.childNodes[range.startOffset];
            } else {
                let node = range.commonAncestorContainer;
                if (node.nodeType === 3) {
                    node = node.parentElement;
                }

                let currentNode = node;
                while (currentNode && currentNode !== element) {
                    if (currentNode.nodeName === 'RUBY') {
                        rubyElement = currentNode;
                        break;
                    }
                    currentNode = currentNode.parentElement;
                }
            }

            if (rubyElement) {
                // ベーステキストを取得
                const baseText = Array.from(rubyElement.childNodes)
                    .filter(n => n.nodeName !== 'RT')
                    .map(n => n.textContent)
                    .join('');

                // テキストノードを作成
                const textNode = document.createTextNode(baseText);

                // 前後のゼロ幅スペースを削除
                const prevNode = rubyElement.previousSibling;
                const nextNode = rubyElement.nextSibling;

                if (prevNode && prevNode.nodeType === 3 && prevNode.textContent === '\u200B') {
                    prevNode.remove();
                }
                if (nextNode && nextNode.nodeType === 3 && nextNode.textContent === '\u200B') {
                    nextNode.remove();
                }

                // ruby要素をテキストノードに置き換え
                rubyElement.parentNode.replaceChild(textNode, rubyElement);

                // カーソルをテキストの末尾に移動
                const newRange = document.createRange();
                newRange.setStart(textNode, textNode.textContent.length);
                newRange.collapse(true);
                selection.removeAllRanges();
                selection.addRange(newRange);

                element.focus();
            }

            element.scrollTop = scrollTop;
            savedSelection = null;
        };

        window.checkRubySelection = function(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return null;

            const selection = window.getSelection();
            if (selection.rangeCount === 0) return null;

            const range = selection.getRangeAt(0);

            // ruby要素全体が選択されているかチェック
            if (range.startContainer === range.endContainer &&
                range.startContainer.nodeType === 1) {
                const selectedNode = range.startContainer.childNodes[range.startOffset];
                if (selectedNode && selectedNode.nodeName === 'RUBY') {
                    const baseText = Array.from(selectedNode.childNodes)
                        .filter(n => n.nodeName !== 'RT')
                        .map(n => n.textContent)
                        .join('');
                    const rtElement = selectedNode.querySelector('rt');
                    const rubyText = rtElement ? rtElement.textContent : '';

                    return [baseText, rubyText];
                }
            }

            // 選択範囲の開始・終了位置からruby要素を探す
            let startNode = range.startContainer;
            let endNode = range.endContainer;

            // テキストノードの場合は親要素を取得
            if (startNode.nodeType === 3) {
                startNode = startNode.parentElement;
            }
            if (endNode.nodeType === 3) {
                endNode = endNode.parentElement;
            }

            // 開始位置と終了位置が同じruby要素内にあるかチェック
            let startRuby = null;
            let endRuby = null;

            let node = startNode;
            while (node && node !== element) {
                if (node.nodeName === 'RUBY') {
                    startRuby = node;
                    break;
                }
                node = node.parentElement;
            }

            node = endNode;
            while (node && node !== element) {
                if (node.nodeName === 'RUBY') {
                    endRuby = node;
                    break;
                }
                node = node.parentElement;
            }

            // 同じruby要素内の選択、またはカーソルがruby要素内にある場合
            if (startRuby && startRuby === endRuby) {
                const baseText = Array.from(startRuby.childNodes)
                    .filter(n => n.nodeName !== 'RT')
                    .map(n => n.textContent)
                    .join('');
                const rtElement = startRuby.querySelector('rt');
                const rubyText = rtElement ? rtElement.textContent : '';

                // ruby要素全体を選択し直す
                const newRange = document.createRange();
                newRange.selectNode(startRuby);
                selection.removeAllRanges();
                selection.addRange(newRange);

                return [baseText, rubyText];
            }

            // 複数のruby要素にまたがる選択の場合はnullを返す（新規追加として扱う）
            const fragment = range.cloneContents();
            const tempDiv = document.createElement('div');
            tempDiv.appendChild(fragment);
            const rubysInSelection = tempDiv.querySelectorAll('ruby');

            if (rubysInSelection.length > 0) {
                return null;
            }

            return null;
        };

        // contenteditable要素のクリックイベントを監視
        document.addEventListener('click', function(e) {
            const target = e.target;

            // content-editableまたはcontent-editable-mobile内のクリックか確認
            let editableElement = null;
            if (target.id === 'content-editable' || target.id === 'content-editable-mobile') {
                editableElement = target;
            } else {
                let parent = target.parentElement;
                while (parent) {
                    if (parent.id === 'content-editable' || parent.id === 'content-editable-mobile') {
                        editableElement = parent;
                        break;
                    }
                    parent = parent.parentElement;
                }
            }

            if (!editableElement) return;

            // ruby要素またはその子要素がクリックされた場合の処理
            let rubyElement = null;
            if (target.nodeName === 'RUBY') {
                rubyElement = target;
            } else if (target.nodeName === 'RT') {
                rubyElement = target.parentElement;
            } else if (target.parentElement?.nodeName === 'RUBY') {
                rubyElement = target.parentElement;
            }

            if (rubyElement) {
                // ruby要素全体を選択
                const selection = window.getSelection();
                const range = document.createRange();
                range.selectNode(rubyElement);
                selection.removeAllRanges();
                selection.addRange(range);

                e.preventDefault();
                return;
            }

            // クリック位置が末尾付近で、最後の要素がrubyの場合
            const rect = editableElement.getBoundingClientRect();
            const clickY = e.clientY;

            // 下半分をクリックした場合
            if (clickY > rect.top + rect.height / 2) {
                const lastChild = editableElement.lastChild;
                let needsNewLine = false;

                // 最後の要素がrubyまたはゼロ幅スペースの場合
                if (lastChild) {
                    if (lastChild.nodeName === 'RUBY') {
                        needsNewLine = true;
                    } else if (lastChild.nodeType === 3 && lastChild.textContent === '\u200B' &&
                               lastChild.previousSibling?.nodeName === 'RUBY') {
                        needsNewLine = true;
                    }
                }

                if (needsNewLine) {
                    // 末尾にテキストノードを追加
                    const textNode = document.createTextNode('\u200B');
                    editableElement.appendChild(textNode);

                    const selection = window.getSelection();
                    const range = document.createRange();
                    range.setStart(textNode, 1);
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);

                    editableElement.focus();
                    e.preventDefault();
                }
            }
        });

        // ruby要素内での直接入力を防ぐ
        document.addEventListener('beforeinput', function(e) {
            const target = e.target;

            // content-editableまたはcontent-editable-mobile内の入力か確認
            if (target.id !== 'content-editable' && target.id !== 'content-editable-mobile') {
                return;
            }

            const selection = window.getSelection();
            if (selection.rangeCount === 0) return;

            const range = selection.getRangeAt(0);
            let node = range.startContainer;

            // テキストノードの場合は親要素を取得
            if (node.nodeType === 3) {
                node = node.parentElement;
            }

            // ruby要素内またはrt要素内にいるかチェック
            let currentNode = node;
            let rubyElement = null;

            while (currentNode && currentNode !== target) {
                if (currentNode.nodeName === 'RUBY') {
                    rubyElement = currentNode;
                    break;
                }
                if (currentNode.nodeName === 'RT') {
                    // rt要素内の場合、親のruby要素を取得
                    rubyElement = currentNode.parentElement;
                    break;
                }
                currentNode = currentNode.parentElement;
            }

            // ruby要素内での入力を検出した場合
            if (rubyElement) {
                e.preventDefault();

                // ruby要素の直後にカーソルを移動
                const newRange = document.createRange();
                const afterNode = rubyElement.nextSibling;

                if (afterNode && afterNode.nodeType === 3 && afterNode.textContent === '\u200B') {
                    // 既存のゼロ幅スペースにカーソルを移動
                    newRange.setStart(afterNode, 1);
                } else {
                    // ゼロ幅スペースを追加
                    const zeroWidthSpace = document.createTextNode('\u200B');
                    if (rubyElement.nextSibling) {
                        rubyElement.parentNode.insertBefore(zeroWidthSpace, rubyElement.nextSibling);
                    } else {
                        rubyElement.parentNode.appendChild(zeroWidthSpace);
                    }
                    newRange.setStart(zeroWidthSpace, 1);
                }

                newRange.collapse(true);
                selection.removeAllRanges();
                selection.addRange(newRange);

                // 入力内容が文字の場合は、カーソル位置に挿入
                if (e.data) {
                    document.execCommand('insertText', false, e.data);
                }

                return;
            }
        });

        // inputイベントでもチェック（ペーストや部分削除などの場合）
        document.addEventListener('input', function(e) {
            const target = e.target;

            // content-editableまたはcontent-editable-mobile内の変更か確認
            if (target.id !== 'content-editable' && target.id !== 'content-editable-mobile') {
                return;
            }

            // すべてのruby要素をチェック
            const rubyElements = target.querySelectorAll('ruby');
            const elementsToRemove = [];

            rubyElements.forEach(ruby => {
                // 元のruby構造が壊れているかチェック
                const rtElement = ruby.querySelector('rt');

                // rtがない、または子要素の構造が不正な場合は削除
                if (!rtElement) {
                    elementsToRemove.push(ruby);
                    return;
                }

                // rt要素以外のテキストを取得
                let baseText = '';
                let hasOnlyTextAndRt = true;

                Array.from(ruby.childNodes).forEach(node => {
                    if (node.nodeName === 'RT') {
                        // rtはスキップ
                    } else if (node.nodeType === 3) {
                        // テキストノード
                        baseText += node.textContent;
                    } else {
                        // その他の要素が含まれている場合は構造が壊れている
                        hasOnlyTextAndRt = false;
                    }
                });

                // 構造が壊れているか、ベーステキストが空の場合は削除
                if (!hasOnlyTextAndRt || !baseText || baseText.trim() === '') {
                    elementsToRemove.push(ruby);
                }
            });

            // 削除対象のruby要素を削除
            elementsToRemove.forEach(ruby => {
                // 前後のゼロ幅スペースも削除
                const prevNode = ruby.previousSibling;
                const nextNode = ruby.nextSibling;

                if (prevNode && prevNode.nodeType === 3 && prevNode.textContent === '\u200B') {
                    prevNode.remove();
                }
                if (nextNode && nextNode.nodeType === 3 && nextNode.textContent === '\u200B') {
                    nextNode.remove();
                }

                ruby.remove();
            });

            // 空の書式タグを削除
            cleanupEmptyFormatTags(target);
        });

        // 空の書式タグを削除する関数を修正
        function cleanupEmptyFormatTags(element) {
            const formatTags = ['B', 'STRONG', 'I', 'EM', 'U'];

            formatTags.forEach(tagName => {
                const tags = element.querySelectorAll(tagName.toLowerCase());
                tags.forEach(tag => {
                    // テキストコンテンツを取得（ゼロ幅スペースを除く）
                    const text = tag.textContent.replace(/\u200B/g, '').trim();

                    // 空の場合、または子要素がなくゼロ幅スペースのみの場合は削除
                    if (!text || (tag.childNodes.length === 1 && tag.textContent === '\u200B')) {
                        // 前後のゼロ幅スペースも削除
                        const prevNode = tag.previousSibling;
                        const nextNode = tag.nextSibling;

                        if (prevNode && prevNode.nodeType === 3 && prevNode.textContent === '\u200B') {
                            prevNode.remove();
                        }
                        if (nextNode && nextNode.nodeType === 3 && nextNode.textContent === '\u200B') {
                            nextNode.remove();
                        }

                        tag.remove();
                    }
                });
            });
        }

        // テキスト入力時のUndoスタック管理
        window.setupInputUndoTracking = function() {
            let inputTimeout = null;
            let lastInputTime = 0;

            // beforeinput: 入力前の状態を保存
            document.addEventListener('beforeinput', function(e) {
                const target = e.target;

                // content-editableまたはcontent-editable-mobile内の入力か確認
                if (target.id !== 'content-editable' && target.id !== 'content-editable-mobile') {
                    return;
                }

                const elementId = target.id;

                // 初期状態を保存（初回のみ）
                if (lastSavedContent[elementId] === undefined) {
                    lastSavedContent[elementId] = target.innerHTML;
                }
            }, true);

            // inputイベントでの自動保存
            document.addEventListener('input', function(e) {
                const target = e.target;

                // content-editableまたはcontent-editable-mobile内の入力か確認
                if (target.id !== 'content-editable' && target.id !== 'content-editable-mobile') {
                    return;
                }

                const elementId = target.id;
                const currentTime = Date.now();

                // 初期状態を保存（初回のみ）
                if (lastSavedContent[elementId] === undefined) {
                    lastSavedContent[elementId] = target.innerHTML;
                }

                // inputイベント発生時、タイマーをリセット
                if (inputTimeout) {
                    clearTimeout(inputTimeout);
                }

                // 500ms間入力がなければUndoスタックに保存
                inputTimeout = setTimeout(function() {
                    const currentContent = target.innerHTML;
                    const previousContent = lastSavedContent[elementId];

                    // 内容が変わっている場合のみ保存
                    if (previousContent !== undefined && previousContent !== currentContent) {
                        // 前の状態をundoスタックに保存
                        const state = {
                            html: previousContent,
                            selection: saveSelectionState(target)
                        };

                        undoStack.push(state);
                        if (undoStack.length > MAX_UNDO_STACK) {
                            undoStack.shift();
                        }
                        redoStack = []; // 新しい入力でredoスタックをクリア

                        lastSavedContent[elementId] = currentContent;
                        notifyUndoRedoStates();

                        console.log('Undo state saved:', undoStack.length);
                    }
                }, 500); // 500msのディレイ（1秒から短縮）

                lastInputTime = currentTime;
            }, true); // キャプチャフェーズで実行

            // キーボードショートカット (Ctrl+Z, Ctrl+Y)
            document.addEventListener('keydown', function(e) {
                const target = e.target;

                // content-editableまたはcontent-editable-mobile内の入力か確認
                if (target.id !== 'content-editable' && target.id !== 'content-editable-mobile') {
                    return;
                }

                const elementId = target.id;

                if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                    e.preventDefault();

                    // タイマーがある場合は即座に保存してからUndo
                    if (inputTimeout) {
                        clearTimeout(inputTimeout);
                        inputTimeout = null;

                        const currentContent = target.innerHTML;
                        const previousContent = lastSavedContent[elementId];

                        if (previousContent !== undefined && previousContent !== currentContent) {
                            undoStack.push({
                                html: previousContent,
                                selection: saveSelectionState(target)
                            });
                            lastSavedContent[elementId] = currentContent;
                            redoStack = [];
                            notifyUndoRedoStates();

                            console.log('Undo state saved on Ctrl+Z:', undoStack.length);
                        }
                    }

                    window.undoEditor(elementId);
                } else if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
                    e.preventDefault();
                    window.redoEditor(elementId);
                }
            }, true); // キャプチャフェーズで実行
        };

        // キーボード入力でのruby削除処理を追加
        document.addEventListener('keydown', function(e) {
            const target = e.target;

            // content-editableまたはcontent-editable-mobile内の入力か確認
            if (target.id !== 'content-editable' && target.id !== 'content-editable-mobile') {
                return;
            }

            // BackspaceまたはDeleteキーの場合
            if (e.key === 'Backspace' || e.key === 'Delete') {
                const selection = window.getSelection();

                if (selection && selection.rangeCount > 0 && !selection.isCollapsed) {
                    // 選択範囲がある場合、削除前に現在の状態を保存
                    const element = document.getElementById(target.id);
                    if (element) {
                        const state = {
                            html: element.innerHTML,
                            selection: saveSelectionState(element)
                        };
                        undoStack.push(state);
                        if (undoStack.length > MAX_UNDO_STACK) {
                            undoStack.shift();
                        }
                        redoStack = [];
                        lastSavedContent[target.id] = element.innerHTML;
                        notifyUndoRedoStates();
                    }
                }
                if (selection.rangeCount === 0) return;

                const range = selection.getRangeAt(0);

                // 選択範囲がある場合
                if (!selection.isCollapsed) {
                    const fragment = range.cloneContents();
                    const tempDiv = document.createElement('div');
                    tempDiv.appendChild(fragment);

                    // 選択範囲内または部分的に含まれるruby要素をチェック
                    let affectedRubies = [];

                    // 範囲の開始・終了コンテナからruby要素を探す
                    let startNode = range.startContainer;
                    let endNode = range.endContainer;

                    // 開始位置のruby要素をチェック
                    let node = startNode;
                    while (node && node !== target) {
                        if (node.nodeName === 'RUBY') {
                            affectedRubies.push(node);
                            break;
                        }
                        node = node.parentElement;
                    }

                    // 終了位置のruby要素をチェック（開始と異なる場合）
                    node = endNode;
                    while (node && node !== target) {
                        if (node.nodeName === 'RUBY' && !affectedRubies.includes(node)) {
                            affectedRubies.push(node);
                            break;
                        }
                        node = node.parentElement;
                    }

                    // 範囲内のすべてのruby要素もチェック
                    const rangeRubies = tempDiv.querySelectorAll('ruby');
                    if (rangeRubies.length > 0) {
                        // 実際のDOM内で対応するruby要素を見つける
                        const allRubies = target.querySelectorAll('ruby');
                        allRubies.forEach(ruby => {
                            if (range.intersectsNode(ruby) && !affectedRubies.includes(ruby)) {
                                affectedRubies.push(ruby);
                            }
                        });
                    }

                    if (affectedRubies.length > 0) {
                        e.preventDefault();

                        // 影響を受けるruby要素を全て削除
                        affectedRubies.forEach(ruby => {
                            const prevNode = ruby.previousSibling;
                            const nextNode = ruby.nextSibling;

                            if (prevNode && prevNode.nodeType === 3 && prevNode.textContent === '\u200B') {
                                prevNode.remove();
                            }
                            if (nextNode && nextNode.nodeType === 3 && nextNode.textContent === '\u200B') {
                                nextNode.remove();
                            }

                            ruby.remove();
                        });

                        // 選択範囲内の他のコンテンツも削除
                        if (selection.rangeCount > 0) {
                            const newRange = selection.getRangeAt(0);
                            newRange.deleteContents();
                        }

                        return;
                    }

                    // ruby要素が含まれない通常の削除
                    const hasRuby = tempDiv.querySelector('ruby') !== null;
                    if (hasRuby) {
                        e.preventDefault();
                        range.deleteContents();

                        // 削除後のクリーンアップは後続の処理で行われる
                        setTimeout(() => {
                            const rubyElements = target.querySelectorAll('ruby');
                            rubyElements.forEach(ruby => {
                                const baseText = Array.from(ruby.childNodes)
                                    .filter(n => n.nodeName !== 'RT')
                                    .map(n => n.textContent)
                                    .join('');

                                if (!baseText || baseText.trim() === '') {
                                    const prevNode = ruby.previousSibling;
                                    const nextNode = ruby.nextSibling;

                                    if (prevNode && prevNode.nodeType === 3 && prevNode.textContent === '\u200B') {
                                        prevNode.remove();
                                    }
                                    if (nextNode && nextNode.nodeType === 3 && nextNode.textContent === '\u200B') {
                                        nextNode.remove();
                                    }

                                    ruby.remove();
                                }
                            });
                        }, 0);
                    }
                } else {
                    // カーソル位置のみの場合（選択範囲なし）
                    const node = range.startContainer;
                    let rubyElement = null;

                    // ruby要素の中または隣接しているかチェック
                    if (node.nodeType === 3) {
                        // テキストノードの場合、親がrubyかチェック
                        let parent = node.parentElement;
                        while (parent && parent !== target) {
                            if (parent.nodeName === 'RUBY') {
                                rubyElement = parent;
                                break;
                            }
                            parent = parent.parentElement;
                        }

                        // ruby要素の直前または直後にいるかチェック
                        if (!rubyElement) {
                            if (e.key === 'Backspace') {
                                // ゼロ幅スペース位置での削除を修正
                                if (node.textContent === '\u200B' && range.startOffset === 1) {
                                    const prevNode = node.previousSibling;
                                    if (prevNode?.nodeName === 'RUBY') {
                                        rubyElement = prevNode;
                                    }
                                } else if (range.startOffset === 0 && node.previousSibling?.nodeName === 'RUBY') {
                                    rubyElement = node.previousSibling;
                                }
                            } else if (e.key === 'Delete') {
                                // Deleteの場合、直後のノードをチェック
                                if (node.textContent === '\u200B' && range.startOffset === 0) {
                                    const nextNode = node.nextSibling;
                                    if (nextNode?.nodeName === 'RUBY') {
                                        rubyElement = nextNode;
                                    }
                                } else if (range.startOffset === node.textContent.length && node.nextSibling?.nodeName === 'RUBY') {
                                    rubyElement = node.nextSibling;
                                }
                            }
                        }
                    } else if (node.nodeType === 1) {
                        // 要素ノードの場合
                        if (e.key === 'Backspace' && range.startOffset > 0) {
                            const prevNode = node.childNodes[range.startOffset - 1];
                            if (prevNode?.nodeName === 'RUBY') {
                                rubyElement = prevNode;
                            }
                        } else if (e.key === 'Delete' && range.startOffset < node.childNodes.length) {
                            const nextNode = node.childNodes[range.startOffset];
                            if (nextNode?.nodeName === 'RUBY') {
                                rubyElement = nextNode;
                            }
                        }
                    }

                    // ruby要素が見つかった場合、全体を削除
                    if (rubyElement) {
                        e.preventDefault();

                        // 前後のゼロ幅スペースも削除
                        const prevNode = rubyElement.previousSibling;
                        const nextNode = rubyElement.nextSibling;
                        const parentNode = rubyElement.parentNode;

                        const isAfterRuby = e.key === 'Backspace';

                        if (prevNode && prevNode.nodeType === 3 && prevNode.textContent === '\u200B') {
                            prevNode.remove();
                        }
                        if (nextNode && nextNode.nodeType === 3 && nextNode.textContent === '\u200B') {
                            nextNode.remove();
                        }

                        rubyElement.remove();

                        // カーソル位置を適切に設定
                        const newRange = document.createRange();
                        if (isAfterRuby && parentNode.lastChild) {
                            // Backspaceの場合、削除位置の直前に配置
                            newRange.selectNodeContents(parentNode);
                            newRange.collapse(false);
                        } else if (parentNode.firstChild) {
                            newRange.setStartBefore(parentNode.firstChild);
                            newRange.collapse(true);
                        } else {
                            newRange.selectNodeContents(parentNode);
                            newRange.collapse(true);
                        }

                        selection.removeAllRanges();
                        selection.addRange(newRange);
                    }
                }
            }
        });

        window.saveSelectionForRuby = function(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return;

            const selection = window.getSelection();

            // 選択範囲が存在し、かつeditable要素内にあるかチェック
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                let node = range.commonAncestorContainer;

                // editable要素内にあるかチェック
                let isInside = false;
                let checkNode = node;
                while (checkNode) {
                    if (checkNode === element) {
                        isInside = true;
                        break;
                    }
                    checkNode = checkNode.parentNode;
                }

                if (isInside) {
                    // 要素内にある場合は現在の位置を保存
                    savedSelection = {
                        range: range.cloneRange(),
                        elementId: elementId
                    };
                    return;
                }
            }

            // 要素内にない場合、または選択範囲がない場合は末尾に移動
            element.focus();
            const newRange = document.createRange();

            // 要素の末尾にカーソルを配置
            if (element.childNodes.length > 0) {
                const lastChild = element.lastChild;

                // 最後の子要素がテキストノードの場合
                if (lastChild.nodeType === 3) {
                    newRange.setStart(lastChild, lastChild.textContent.length);
                } else {
                    // それ以外の場合は要素の末尾
                    newRange.selectNodeContents(element);
                    newRange.collapse(false);
                }
            } else {
                // 子要素がない場合は要素自体の末尾
                newRange.selectNodeContents(element);
                newRange.collapse(false);
            }

            newRange.collapse(true);

            savedSelection = {
                range: newRange,
                elementId: elementId
            };

            selection.removeAllRanges();
            selection.addRange(newRange);
        };

        window.clearFormat = function(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return;

            saveUndoState(elementId);

            element.focus();
            const selection = window.getSelection();

            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);

                if (!selection.isCollapsed) {
                    const fragment = range.extractContents();
                    const tempDiv = document.createElement('div');
                    tempDiv.appendChild(fragment);

                    // すべてのタグを削除してプレーンテキストに
                    const textContent = tempDiv.textContent;
                    const textNode = document.createTextNode(textContent);

                    range.insertNode(textNode);
                    range.collapse(false);
                    selection.removeAllRanges();
                    selection.addRange(range);
                } else {
                    const currentNode = range.startContainer;
                    let blockElement = currentNode.nodeType === 3 ? currentNode.parentElement : currentNode;

                    while (blockElement && blockElement !== element && !isBlockElement(blockElement)) {
                        blockElement = blockElement.parentElement;
                    }

                    if (blockElement && blockElement !== element) {
                        const offset = getCaretOffset(blockElement, range);
                        const textContent = blockElement.textContent;

                        const newElement = document.createElement('p');
                        newElement.textContent = textContent;
                        blockElement.parentNode.replaceChild(newElement, blockElement);

                        restoreCaretOffset(newElement, offset);
                    }
                }
            }

            currentFormat.bold = false;
            currentFormat.italic = false;
            currentFormat.underline = false;
            notifyFormatStates();
        };
    })();

    window.getCurrentTextColor = function(elementId) {
        try {
            const element = document.getElementById(elementId);
            if (!element) {
                return '#000000';
            }

            const selection = window.getSelection();
            if (selection.rangeCount === 0) {
                console.log('No selection range');
                return '#000000';
            }

            const range = selection.getRangeAt(0);
            let node = range.startContainer;

            // テキストノードの場合、親要素を取得
            if (node.nodeType === 3) {
                node = node.parentElement;
            }

            // カレント位置の色を取得
            while (node && node !== element) {
                const color = window.getComputedStyle(node).color;
                if (color && color !== 'rgb(0, 0, 0)' && color !== 'rgba(0, 0, 0, 0)') {
                    // rgb(r, g, b)形式を#rrggbb形式に変換
                    const rgb = color.match(/\d+/g);
                    if (rgb && rgb.length >= 3) {
                        const hex = '#' + rgb.slice(0, 3).map(x => {
                            const h = parseInt(x).toString(16);
                            return h.length === 1 ? '0' + h : h;
                        }).join('');
                        return hex;
                    }
                }
                node = node.parentElement;
            }

            console.log('Defaulting to black');
            return '#000000';
        } catch (error) {
            console.error('getCurrentTextColor error:', error);
            return '#000000';
        }
    };

    window.positionColorPickerDropdown = function() {
        const btnColor = document.getElementById('color-indicator-btn');
        const dropdown = document.getElementById('color-picker-dropdown');

        if (btnColor && dropdown) {
            const rect = btnColor.getBoundingClientRect();
            dropdown.style.top = (rect.bottom + 10) + 'px';
            dropdown.style.left = rect.left + 'px';
        }
    };

    window.getActiveEditorContent = function () {
        if (window.mobileEditor) {
            return window.mobileEditor.getContent();
        }
        if (window.pcEditor) {
            return window.pcEditor.getContent();
        }
        return "";
    };
</script>